(defm u1  (v) (cast v u1))
(defm u8  (v) (cast v u8))
(defm u16 (v) (cast v u16))
(defm u32 (v) (cast v u32))
(defm u64 (v) (cast v u64))
(defm u128 (v) (cast v u128))

(defm i8  (v) (cast v i8))
(defm i16 (v) (cast v i16))
(defm i32 (v) (cast v i32))
(defm i64 (v) (cast v i64))
(defm i128 (v) (cast v i128))

(defm f32 (v) (cast v f32))
(defm f64 (v) (cast v f64))

(defm zero-if (Q v) (if Q v (vector-zero-top v)))

(defm shift-string (shift) (match shift
    0b00 "LSL"
    0b01 "LSR"
    0b10 "ASR"
    "ROR"))

(defm with-fp16 (code) (unimplemented))

(defm do-shift32 (value shift-type amount) (do-shift-common value shift-type amount u32 i32))
(defm do-shift64 (value shift-type amount) (do-shift-common value shift-type amount u64 i64))
(defm do-shift-common (value shift-type amount utype itype)
    (match shift-type
        0b00 (<< (utype value) amount)
        0b01 (>> value amount)
        0b10 (utype (>> (itype value) amount))
        (>>> value amount)))

(defm add-with-carry-set-nzcv32 (operand1 operand2 carryIn)
    (add-with-carry-set-nzcv-common operand1 operand2 carryIn i32 u32 u64))
(defm add-with-carry-set-nzcv64 (operand1 operand2 carryIn)
    (add-with-carry-set-nzcv-common operand1 operand2 carryIn i64 u64 u128))
(defm add-with-carry-set-nzcv-common (operand1 operand2 carryIn stype utype butype)
    (block
        (let $operand1 (utype operand1)) (let $operand2 (utype operand2)) (let $carryIn (utype carryIn))
        (let bits (bitwidth utype)) (let bits1 (- bits 1))
      
        (let usum (+ (+ $operand1 $operand2) $carryIn))
        (let ssum (+ (+ (stype $operand1) (stype $operand2)) (stype $carryIn)))
        (= (nzcv n) (>> usum bits1))
        (= (nzcv z) (== usum 0))
        (= (nzcv c) (& (u32 (>> (+ (+ (butype $operand1) (butype $operand2)) (butype $carryIn)) bits)) 1))
        (= (nzcv v) (& (== (>> $operand1 bits1) (>> $operand2 bits1)) (!= (>> usum bits1) (>> $operand1 bits1))))
        usum))

(defm polynomial* (op1 op2 iwidth otype)
    (let result (otype (^ op1 op1))
        (for (i iwidth)
            (when (& (>> op1 i) 1)
                (= result (^ result (<< (otype op2) i)))))))

(defm fcmp (_a _b)
    (let $a _a (let $b _b)
        (= (nzcv) (u32 (<<
            (if (| (NaN? $a) (NaN? $b)) 0b0011
            (if (== $a $b) 0b0110
            (if (< $a $b) 0b1000
            0b0010))) 28)))))

(defm f<< (value shift ftype utype)
    (bitcast (<< (bitcast value utype) shift) ftype))

(defm qfor (var middle end block)
    (if Q
        (for (var end) block)
        (for (var middle) block)))

(def ADCS
    "s 0 1 11010000 mmmmm 000000 nnnnn ddddd"
    "adcs $r$rd, $r$rn, $r$rm"
    (names (size s) (rm m) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (add-with-carry-set-nzcv32 (gpr32 rn) (gpr32 rm) (nzcv c)))
        (= (gpr64 rd) (add-with-carry-set-nzcv64 (gpr64 rn) (gpr64 rm) (nzcv c)))))

(def ADD-extended-register
    "s 0 0 01011 00 1 mmmmm ooo iii nnnnn ddddd"
    "add $r1$rd, $r1$rn, $r2$rm, $extend #$imm"
    (names (size s) (rm m) (option o) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm 4))
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (if (== (& option 0b011) 0b011) "X" "W"))
        (let extend (if (== size 0)
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "LSL"
                0b011 "UXTX"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX")
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "UXTW"
                0b011 "LSL"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX"))))
    (if (== size 0)
        (let m (gpr32 rm)
            (= (gpr-or-sp32 rd) (+ (gpr-or-sp32 rn) (<< (match option
                0b000 (& m 0xFF)
                0b001 (& m 0xFFFF)
                0b100 (u32 (signext (u8 m) i32))
                0b101 (u32 (signext (u16 m) i32))
                m) imm))))
        (if (== (& option 0b011) 0b011)
            (= (gpr-or-sp64 rd) (+ (gpr-or-sp64 rn) (<< (gpr64 rm) imm)))
            (let m (u64 (gpr32 rm))
                (= (gpr-or-sp64 rd) (+ (gpr-or-sp64 rn) (<< (match option
                    0b000 (& m 0xFF)
                    0b001 (& m 0xFFFF)
                    0b010 (& m 0xFFFFFFFF)
                    0b100 (u64 (signext (u8 m) i64))
                    0b101 (u64 (signext (u16 m) i64))
                    0b110 (u64 (signext (u32 m) i64))
                    m) imm)))))))

(def ADD-immediate
    "f 0 0 10001 0s iiiiiiiiiiii nnnnn ddddd"
    "add $r$rd, $r$rn, #$imm, LSL #$shift"
    (names (size f) (sh s) (imm i) (rd d) (rn n))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shift (if (== sh 0) 0 12))
        (let simm (<< (u32 imm) shift)))
    (if (== size 0)
        (= (gpr-or-sp32 rd) (+ (gpr-or-sp32 rn) simm))
        (= (gpr-or-sp64 rd) (+ (gpr-or-sp64 rn) simm))))

(def ADD-shifted-register
    "f 0 0 01011 ss 0 mmmmm iiiiii nnnnn ddddd"
    "add $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (imm i) (rd d) (rn n) (rm m))
    (block
        (requires (<= imm (if size 63 31)))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
        (= (gpr32 rd) (+ (gpr32 rn) (do-shift32 (gpr32 rm) shift imm)))
        (= (gpr64 rd) (+ (gpr64 rn) (do-shift64 (gpr64 rm) shift imm)))))

(def ADD-vector
    "0 Q 0 01110 ss 1 mmmmm 10000 1 nnnnn ddddd"
    "add V$rd.$ts, V$rn.$ts, V$rm.$ts"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let ts (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        0b11_1 "2D"
        (unimplemented)))
    (let v (match size
            0b00 (vec-uint+ (vec rn) (vec rm) 8)
            0b01 (vec-uint+ (vec rn) (vec rm) 16)
            0b10 (vec-uint+ (vec rn) (vec rm) 32)
            0b11 (vec-uint+ (vec rn) (vec rm) 64)
            (unimplemented))
        (= (vec rd) (if Q v (vector-zero-top v)))))

(def ADDS-extended-register
    "s 0 1 01011 00 1 mmmmm ooo iii nnnnn ddddd"
    "adds $r1$rd, $r1$rn, $r2$rm, $extend #$imm"
    (names (size s) (rm m) (option o) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm 4))
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (if (== (& option 0b011) 0b011) "X" "W"))
        (let extend (if (== size 0)
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "LSL"
                0b011 "UXTX"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX")
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "UXTW"
                0b011 "LSL"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX"))))
    (if (== size 0)
        (let m (gpr32 rm)
            (= (gpr32 rd) (add-with-carry-set-nzcv32 (gpr-or-sp32 rn) (<< (match option
                0b000 (& m 0xFF)
                0b001 (& m 0xFFFF)
                0b100 (u32 (signext (u8 m) i32))
                0b101 (u32 (signext (u16 m) i32))
                m) imm) 0)))
        (if (== (& option 0b011) 0b011)
            (= (gpr64 rd) (add-with-carry-set-nzcv64 (gpr-or-sp64 rn) (<< (gpr64 rm) imm) 0))
            (let m (gpr32 rm)
                (= (gpr64 rd) (add-with-carry-set-nzcv64 (gpr-or-sp64 rn) (<< (u64 (match option
                    0b000 (& m 0xFF)
                    0b001 (& m 0xFFFF)
                    0b010 (& m 0xFFFFFFFF)
                    0b100 (u64 (signext (u8 m) i64))
                    0b101 (u64 (signext (u16 m) i64))
                    0b110 (u64 (signext m i64))
                    m)) imm) 0))))))

(def ADDS-immediate
    "f 0 1 10001 0s iiiiiiiiiiii nnnnn ddddd"
    "adds $r$rd, $r$rn, #$imm, LSL #$shift"
    (names (size f) (sh s) (imm i) (rd d) (rn n))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shift (if (== sh 0) 0 12))
        (let simm (<< (u32 imm) shift)))
    (if (== size 0)
        (= (gpr32 rd) (add-with-carry-set-nzcv32 (gpr-or-sp32 rn) simm 0))
        (= (gpr64 rd) (add-with-carry-set-nzcv64 (gpr-or-sp64 rn) simm 0))))

(def ADDS-shifted-register
    "f 0 1 01011 ss 0 mmmmm iiiiii nnnnn ddddd"
    "adds $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm (if size 63 31)))
        (requires (!= shift 0b11))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
        (= (gpr32 rd) (add-with-carry-set-nzcv32 (gpr32 rn) (do-shift32 (gpr32 rm) shift imm) 0))
        (= (gpr64 rd) (add-with-carry-set-nzcv64 (gpr64 rn) (do-shift64 (gpr64 rm) shift imm) 0))))

(def ADR
    "0 ll 10000 iiiiiiiiiiiiiiiiiii ddddd"
    "adr X$rd, #$addr"
    (names (immlo l) (immhi i) (rd d))
    (block
        (let imm (signext (: immhi immlo) i64))
        (let addr (+ (pc) imm)))
    (= (gpr64 rd) addr))

(def ADRP
    "1 ll 10000 iiiiiiiiiiiiiiiiiii ddddd"
    "adrp X$rd, #$addr"
    (names (immlo l) (immhi i) (rd d))
    (block
        (let imm (signext (: immhi immlo (cast 0b0000_0000_0000 u12)) i64))
        (let addr (+ (: (cast (>> (pc) 12) u52) (cast 0b0000_0000_0000 u12)) imm)))
    (= (gpr64 rd) addr))

(def AND-immediate
    "f 00 100100 u iiiiii ssssss nnnnn ddddd"
    "and $r$rd, $r$rn, #$imm"
    (names (size f) (up u) (immr i) (imms s) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (make-wmask up imms immr 1 (if (== size 0) 32 64))))
    (if (== size 0)
        (= (gpr-or-sp32 rd) (& (gpr32 rn) (u32 imm)))
        (= (gpr-or-sp64 rd) (& (gpr64 rn) imm))))

(def AND-shifted-register
    "f 00 01010 ss 0 mmmmm iiiiii nnnnn ddddd"
    "and $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm (if size 63 31)))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
        (= (gpr32 rd) (& (gpr32 rn) (do-shift32 (gpr32 rm) shift imm)))
        (= (gpr64 rd) (& (gpr64 rn) (do-shift64 (gpr64 rm) shift imm)))))

(def AND-vector
    "0 Q 0 01110 00 1 mmmmm 00011 1 nnnnn ddddd"
    "and V$rd.$ts, V$rn.$ts, V$rm.$ts"
    (names (Q Q) (rm m) (rn n) (rd d))
    (let ts (if Q "16B" "8B"))
    (let v (vec& (vec rn) (vec rm))
        (= (vec rd) (if Q v (vector-zero-top v)))))

(def ANDS-shifted-register
    "f 11 01010 ss 0 mmmmm iiiiii nnnnn ddddd"
    "ands $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (imm i) (rm m) (rn n) (rd d))
    (block
        (requires (<= imm (if size 63 31)))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
        (let result (& (gpr32 rn) (do-shift32 (gpr32 rm) shift imm))
            (= (gpr32 rd) result)
            (= (nzcv n) (>> result 31))
            (= (nzcv z) (== result 0))
            (= (nzcv c) 0)
            (= (nzcv v) 0))
        (let result (& (gpr64 rn) (do-shift64 (gpr64 rm) shift imm))
            (= (gpr64 rd) result)
            (= (nzcv n) (>> result 63))
            (= (nzcv z) (== result 0))
            (= (nzcv c) 0)
            (= (nzcv v) 0))))

(def ANDS-immediate
    "f 11 100100 u rrrrrr ssssss nnnnn ddddd"
    "ands $r$rd, $r$rn, #$imm"
    (names (size f) (up u) (immr r) (imms s) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (make-wmask up imms immr 1 (if (== size 0) 32 64))))
    (if (== size 0)
        (let result (& (gpr32 rn) imm)
            (= (gpr32 rd) result)
            (= (nzcv n) (>> result 31))
            (= (nzcv z) (== result 0))
            (= (nzcv c) 0)
            (= (nzcv v) 0))
        (let result (& (gpr64 rn) imm)
            (= (gpr64 rd) result)
            (= (nzcv n) (>> result 63))
            (= (nzcv z) (== result 0))
            (= (nzcv c) 0)
            (= (nzcv v) 0))))

(def ASRV
    "s 0 0 11010110 mmmmm 0010 10 nnnnn ddddd"
    "asrv $r$rd, $r$rn, $r$rm"
    (names (size s) (rd d) (rn n) (rm m))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (u32 (>> (i32 (gpr32 rn)) (% (gpr32 rm) 32))))
        (= (gpr64 rd) (u64 (>> (i64 (gpr64 rn)) (% (gpr64 rm) 64))))))

(def B
    "0 00101 iiiiiiiiiiiiiiiiiiiiiiiiii"
    "b #$addr"
    (names (imm i))
    (let addr (+ (pc) (signext (<< (cast imm u28) 2) i64)))
    (branch addr))

(def B.cond
    "0101010 0 iiiiiiiiiiiiiiiiiii 0 cccc"
    "b.$condstr #$addr"
    (names (imm i) (cond c))
    (block
        (let addr (+ (pc) (signext (<< (cast imm u21) 2) i64)))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (block
        (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1))
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (branch addr)
            (branch-default))))

(def BFM
    "f 01 100110 o pppppp ssssss nnnnn ddddd"
    "bfm $r$rd, $r$rn, #$immr, #$imms"
    (names (N o) (size f) (immr p) (imms s) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (block
            (requires (<= immr 31))
            (requires (<= imms 31))
            (requires (== N 0))
            (let dst (gpr32 rd))
            (let src (gpr32 rn))
            (let wmask (u32 (make-wmask N imms immr 0 32)))
            (let tmask (u32 (make-tmask N imms immr 0 32)))
            (let bot (| (& dst (~ wmask)) (& (>>> src immr) wmask)))
            (= (gpr32 rd) (| (& dst (~ tmask)) (& bot tmask))))
        (block
            (requires (<= immr 63))
            (requires (<= imms 63))
            (requires N)
            (let dst (gpr64 rd))
            (let src (gpr64 rn))
            (let wmask (make-wmask N imms immr 0 64))
            (let tmask (make-tmask N imms immr 0 64))
            (let bot (| (& dst (~ wmask)) (& (>>> src immr) wmask)))
            (= (gpr64 rd) (| (& dst (~ tmask)) (& bot tmask))))))

(def BIC
    "f 00 01010 ss 1 mmmmm iiiiii nnnnn ddddd"
    "bic $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm (if size 63 31)))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
        (= (gpr32 rd) (& (gpr32 rn) (~ (do-shift32 (gpr32 rm) shift imm))))
        (= (gpr64 rd) (& (gpr64 rn) (~ (do-shift64 (gpr64 rm) shift imm))))))

(def BIC-vector-register
    "0 Q 0 01110 01 1 mmmmm 00011 1 nnnnn ddddd"
    "bic V$rd.$T, V$rn.$T, V$rm.$T"
    (names (Q Q) (rm m) (rn n) (rd d))
    (let T (if (== Q 1) "16B" "8B"))
    (let v (vec&~ (vec rn) (vec rm))
        (= (vec rd) (if Q v (vector-zero-top v)))))

(def BIC-vector-immediate-16bit
    "0 Q 1 0111100000 a b c 10x1 0 1 d e f g h rrrrr"
    "bic V$rd.$T, #$imm, LSL #$amount"
    (names (Q Q) (a a) (b b) (c c) (cmode x) (d d) (e e) (f f) (g g) (h h) (rd r))
    (mlet (T (if (== Q 1) "16B" "8B") amount (if cmode 8 0))
        (let imm (: a b c d e f g h)))
    (let v (vec&~ (vec rd) (vector-all (u16 (<< (u16 imm) amount))))
        (= (vec rd) (if Q v (vector-zero-top v)))))

(def BIC-vector-immediate-32bit
    "0 Q 1 0111100000 a b c 0xx1 0 1 d e f g h rrrrr"
    "bic V$rd.$T, #$imm, LSL #$amount"
    (names (Q Q) (a a) (b b) (c c) (cmode x) (d d) (e e) (f f) (g g) (h h) (rd r))
    (mlet (T (if (== Q 1) "16B" "8B") amount (<< cmode 3))
        (let imm (: a b c d e f g h)))
    (let v (vec&~ (vec rd) (vector-all (<< (u32 imm) amount)))
        (= (vec rd) (if Q v (vector-zero-top v)))))

(def BICS
    "f 11 01010 ss 1 mmmmm iiiiii nnnnn ddddd"
    "bics $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm (if size 63 31)))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
        (let val (& (gpr32 rn) (~ (do-shift32 (gpr32 rm) shift imm)))
            (= (gpr32 rd) val)
            (= (nzcv) (| (<< (u64 (>> val 31)) 31) (<< (u64 (== val 0)) 30))))
        (let val (& (gpr64 rn) (~ (do-shift64 (gpr64 rm) shift imm)))
            (= (gpr64 rd) val)
            (= (nzcv) (| (<< (u64 (>> val 63)) 31) (<< (u64 (== val 0)) 30))))))

(def BL
    "1 00101 iiiiiiiiiiiiiiiiiiiiiiiiii"
    "bl #$addr"
    (names (imm i))
    (block
        (let offset (signext (<< (cast imm u28) 2) i64))
        (let addr (+ (pc) offset)))
    (branch-linked addr))

(def BLR
    "1101011 0 0 01 11111 0000 0 0 nnnnn 00000"
    "blr X$rn"
    (names (rn n))
    (block)
    (branch-linked-register rn))

(def BR
    "1101011 0 0 00 11111 0000 0 0 nnnnn 00000"
    "br X$rn"
    (names (rn n))
    (block)
    (branch-register rn))

(def BRK
    "11010100 001 iiiiiiiiiiiiiiii 000 00"
    "brk #$imm"
    (names (imm i))
    (block)
    (branch 0xf1f1f1f1f2f2f2f2))

(def BSL
    "0 Q 1 01110 01 1 mmmmm 00011 1 nnnnn ddddd"
    "bsl V$rd.$T, V$rn.$T, V$rm.$T"
    (names (Q Q) (rm m) (rn n) (rd d))
    (let T (if Q "16B" "8B"))
    (mlet (d (vec rd) a (vec rn) b (vec rm) v (vec^ b (vec& (vec^ b a) d)))
        (= (vec rd) (if Q v (vector-zero-top v)))))

(def CASP
    "0 f 001000 0 0 1 sssss 0 11111 nnnnn ttttt"
    "casp $r$rs, $r$rs2, $r$rt, $r$rt2, [X$rn]"
    (names (size f) (rs s) (rn n) (rt t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let rs2 (+ rs 1))
        (let rt2 (+ rt 1)))
    (unimplemented))

(def CASPA
    "0 f 001000 0 1 1 sssss 0 11111 nnnnn ttttt"
    "caspa $r$rs, $r$rs2, $r$rt, $r$rt2, [X$rn]"
    (names (size f) (rs s) (rn n) (rt t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let rs2 (+ rs 1))
        (let rt2 (+ rt 1)))
    (unimplemented))

(def CASPAL
    "0 f 001000 0 1 1 sssss 1 11111 nnnnn ttttt"
    "caspal $r$rs, $r$rs2, $r$rt, $r$rt2, [X$rn]"
    (names (size f) (rs s) (rn n) (rt t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let rs2 (+ rs 1))
        (let rt2 (+ rt 1)))
    (if (== size 0)
        (block
            (let cl (gpr32 rs))
            (let ch (gpr32 (+ rs 1)))
            (let nl (gpr32 rt))
            (let nh (gpr32 (+ rt 1)))
            (let address (gpr-or-sp64 rn))
            (let data (load address u64))
            (if (== data (| (<< (u64 ch) 32) (u64 cl)))
                (store address (| (<< (u64 nh) 32) (u64 nl)))
                (block))
            (= (gpr32 rs) (u32 data))
            (= (gpr32 (+ rs 1)) (u32 (>> data 32))))
        (block
            (let cl (gpr64 rs))
            (let ch (gpr64 (+ rs 1)))
            (let nl (gpr64 rt))
            (let nh (gpr64 (+ rt 1)))
            (let address (gpr-or-sp64 rn))
            (let dl (load address u64))
            (let dh (load (+ address 8) u64))
            (if (& (== dl cl) (== dh ch))
                (block
                    (store address nl)
                    (store (+ address 8) nh))
                (block))
            (= (gpr64 rs) dl)
            (= (gpr64 (+ rs 1)) dh))))

(def CASPL
    "0 f 001000 0 0 1 sssss 1 11111 nnnnn ttttt"
    "caspl $r$rs, $r$rs2, $r$rt, $r$rt2, [X$rn]"
    (names (size f) (rs s) (rn n) (rt t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let rs2 (+ rs 1))
        (let rt2 (+ rt 1)))
    (unimplemented))

(def CBNZ
    "s 011010 1 iiiiiiiiiiiiiiiiiii ttttt"
    "cbnz $r$rs, #$addr"
    (names (size s) (imm i) (rs t))
    (block
         (let r (if (== size 0) "W" "X"))
         (let addr (+ (pc) (signext (cast (<< imm 2) u21) i64))))
    (if (== size 0)
        (if (!= (gpr32 rs) (u32 0))
            (branch addr)
            (branch-default))
        (if (!= (gpr64 rs) (u64 0))
            (branch addr)
            (branch-default))))

(def CBZ
    "s 011010 0 iiiiiiiiiiiiiiiiiii ttttt"
    "cbz $r$rs, #$addr"
    (names (size s) (imm i) (rs t))
    (block
         (let r (if (== size 0) "W" "X"))
         (let addr (+ (pc) (signext (cast (<< imm 2) u21) i64))))
    (if (== size 0)
        (if (== (gpr32 rs) (u32 0))
            (branch addr)
            (branch-default))
        (if (== (gpr64 rs) (u64 0))
            (branch addr)
            (branch-default))))

(def CCMN-immediate
    "s 0 1 11010010 iiiii cccc 1 0 nnnnn 0 zzzz"
    "ccmn $r$rn, #$imm, #$nzcv, $condstr"
    (names (size s) (imm i) (cond c) (rn n) (nzcv z))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 31) (add-with-carry-set-nzcv32 (gpr32 rn) (u32 imm) 0))
                (= (gpr64 31) (add-with-carry-set-nzcv64 (gpr64 rn) (u64 imm) 0)))
            (= (nzcv) (<< (u64 nzcv) 28)))))

(def CCMP-immediate
    "s 1 1 11010010 iiiii cccc 1 0 nnnnn 0 zzzz"
    "ccmp $r$rn, #$imm, #$nzcv, $condstr"
    (names (size s) (imm i) (cond c) (rn n) (nzcv z))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 31) (add-with-carry-set-nzcv32 (gpr32 rn) (~ (u32 imm)) 1))
                (= (gpr64 31) (add-with-carry-set-nzcv64 (gpr64 rn) (~ (u64 imm)) 1)))
            (= (nzcv) (<< (u64 nzcv) 28)))))

(def CCMP-register
    "s 1 1 11010010 mmmmm cccc 0 0 nnnnn 0 zzzz"
    "ccmp $r$rn, $r$rm, #$nzcv, $condstr"
    (names (size s) (rm m) (cond c) (rn n) (nzcv z))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 31) (add-with-carry-set-nzcv32 (gpr32 rn) (~ (gpr32 rm)) 1))
                (= (gpr64 31) (add-with-carry-set-nzcv64 (gpr64 rn) (~ (gpr64 rm)) 1)))
            (= (nzcv) (<< (u64 nzcv) 28)))))

(def CLREX
    "1101010100 0 00 011 0011 mmmm 010 11111"
    "clrex"
    (names (crm m))
    (block)
    (block))

(def CLZ
    "s 1 0 11010110 00000 00010 0 nnnnn ddddd"
    "clz $r$rd, $r$rn"
    (names (size s) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (count-leading-zeros (gpr32 rn)))
        (= (gpr64 rd) (count-leading-zeros (gpr64 rn)))))

(def CMEQ-register-scalar
    "01 1 11110 ss 1 mmmmm 10001 1 nnnnn ddddd"
    "cmeq $V$rd, $V$rn, $V$rm"
    (names (size s) (rm m) (rn n) (rd d))
    (let V (match size
        0b11 "D"
        (unimplemented)))
    (match size
        0b11 (= (vec-d rd) (bitcast (if (== (bitcast (vec-d rn) u64) (bitcast (vec-d rm) u64)) (u64 0xFFFFFFFF_FFFFFFFF) (u64 0)) f64))
        (unimplemented)))

(defm cmeq-sub (index type)
    (vector-insert rd index (if (== (vector-element a index type) (vector-element b index type)) one zero)))

(def CMEQ-register-vector
    "0 Q 1 01110 ss 1 mmmmm 10001 1 nnnnn ddddd"
    "cmeq V$rd.$T, V$rn.$T, V$rm.$T"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let T (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        0b11_1 "2D"
        (unimplemented)))
    (mlet (a (vec rn) b (vec rm))
        (= (vec rd) (vector-all (u8 0)))
        (match size
            0b00 (mlet (one (u8 0xFF) zero (u8 0))
                    (qfor i 8 16 (cmeq-sub i u8)))
            0b01 (mlet (one (u16 0xFFFF) zero (u16 0))
                    (qfor i 4 8 (cmeq-sub i u16)))
            0b10 (mlet (one (u32 0xFFFFFFFF) zero (u32 0))
                    (qfor i 2 4 (cmeq-sub i u32)))
                 (mlet (one (u64 0xFFFFFFFF_FFFFFFFF) zero (u64 0))
                    (qfor i 1 2 (cmeq-sub i u64))))))

(def CMEQ-zero-scalar
    "01 0 11110 ss 10000 0100 1 10 nnnnn ddddd"
    "cmeq $V$rd, $V$rn, #0"
    (names (size s) (rn n) (rd d))
    (let V (match size
        0b11 "D"
        (unimplemented)))
    (match size
        0b11 (= (vec-d rd) (bitcast (if (== (bitcast (vec-d rn) u64) (u64 0)) (u64 0xFFFFFFFF_FFFFFFFF) (u64 0)) f64))
        (unimplemented)))

(defm cmeqz-sub (index type)
    (vector-insert rd index (if (== (vector-element a index type) (type 0)) one zero)))

(def CMEQ-zero-vector
    "0 Q 0 01110 ss 10000 0100 1 10 nnnnn ddddd"
    "cmeq V$rd.$T, V$rn.$T, #0"
    (names (Q Q) (size s) (rn n) (rd d))
    (let T (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        0b11_1 "2D"
        (unimplemented)))
    (let a (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (match size
            0b00 (mlet (one (u8 0xFF) zero (u8 0))
                    (qfor i 8 16 (cmeqz-sub i u8)))
            0b01 (mlet (one (u16 0xFFFF) zero (u16 0))
                    (qfor i 4 8 (cmeqz-sub i u16)))
            0b10 (mlet (one (u32 0xFFFFFFFF) zero (u32 0))
                    (qfor i 2 4 (cmeqz-sub i u32)))
                 (mlet (one (u64 0xFFFFFFFF_FFFFFFFF) zero (u64 0))
                    (qfor i 1 2 (cmeqz-sub i u64))))))

(def CMGT-register-scalar
    "01 0 11110 ss 1 mmmmm 0011 0 1 nnnnn ddddd"
    "cmgt $V$rd, $V$rn, $V$rm"
    (names (size s) (rm m) (rn n) (rd d))
    (let V (match size
        0b11 "D"
        (unimplemented)))
    (match size
        0b11 (= (vec-d rd) (bitcast (if (> (bitcast (vec-d rn) i64) (bitcast (vec-d rm) i64)) (u64 0xFFFFFFFF_FFFFFFFF) (u64 0)) f64))
        (unimplemented)))

(defm cmgt-sub (index type)
    (vector-insert rd index (if (> (vector-element a index type) (vector-element b index type)) one zero)))

(def CMGT-register-vector
    "0 Q 0 01110 ss 1 mmmmm 0011 0 1 nnnnn ddddd"
    "cmgt V$rd.$T, V$rn.$T, V$rm.$T"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let T (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        0b11_1 "2D"
        (unimplemented)))
    (mlet (a (vec rn) b (vec rm))
        (= (vec rd) (vector-all (u8 0)))
        (match size
            0b00 (mlet (one (u8 0xFF) zero (u8 0))
                    (qfor i 8 16 (cmgt-sub i i8)))
            0b01 (mlet (one (u16 0xFFFF) zero (u16 0))
                    (qfor i 4 8 (cmgt-sub i i16)))
            0b10 (mlet (one (u32 0xFFFFFFFF) zero (u32 0))
                    (qfor i 2 4 (cmgt-sub i i32)))
                 (mlet (one (u64 0xFFFFFFFF_FFFFFFFF) zero (u64 0))
                    (qfor i 1 2 (cmgt-sub i i64))))))

(def CMGT-zero-scalar
    "01 0 11110 ss 10000 0100 0 10 nnnnn ddddd"
    "cmgt $V$rd, $V$rn, #0"
    (names (size s) (rn n) (rd d))
    (let V (match size
        0b11 "D"
        (unimplemented)))
    (match size
        0b11 (= (vec-d rd) (bitcast (if (> (bitcast (vec-d rn) i64) (i64 0)) (u64 0xFFFFFFFF_FFFFFFFF) (u64 0)) f64))
        (unimplemented)))

(defm cmgtz-sub (index type)
    (vector-insert rd index (if (> (vector-element a index type) (type 0)) one zero)))

(def CMGT-zero-vector
    "0 Q 0 01110 ss 10000 0100 0 10 nnnnn ddddd"
    "cmeq V$rd.$T, V$rn.$T, #0"
    (names (Q Q) (size s) (rn n) (rd d))
    (let T (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        0b11_1 "2D"
        (unimplemented)))
    (let a (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (match size
            0b00 (mlet (one (u8 0xFF) zero (u8 0))
                    (qfor i 8 16 (cmgtz-sub i i8)))
            0b01 (mlet (one (u16 0xFFFF) zero (u16 0))
                    (qfor i 4 8 (cmgtz-sub i i16)))
            0b10 (mlet (one (u32 0xFFFFFFFF) zero (u32 0))
                    (qfor i 2 4 (cmgtz-sub i i32)))
                 (mlet (one (u64 0xFFFFFFFF_FFFFFFFF) zero (u64 0))
                    (qfor i 1 2 (cmgtz-sub i i64))))))

(def CNT
    "0 q 0 01110 ss 10000 00101 10 nnnnn ddddd"
    "cnt V$rd.$t, V$rn.$t"
    (names (Q q) (size s) (rn n) (rd d))
    (let t (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        (unimplemented)))
    (= (vec rd) (vector-count-bits (vec rn) (match (: size Q) 0b00_0 8 16))))

(def CSEL
    "s 0 0 11010100 mmmmm cccc 0 0 nnnnn ddddd"
    "csel $r$rd, $r$rn, $r$rm, $condstr"
    (names (size s) (rm m) (cond c) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 rd) (gpr32 rn))
                (= (gpr64 rd) (gpr64 rn)))
            (if (== size 0)
                (= (gpr32 rd) (gpr32 rm))
                (= (gpr64 rd) (gpr64 rm))))))

(def CSINC
    "s 0 0 11010100 mmmmm cccc 0 1 nnnnn ddddd"
    "csinc $r$rd, $r$rn, $r$rm, $condstr"
    (names (size s) (rm m) (cond c) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 rd) (gpr32 rn))
                (= (gpr64 rd) (gpr64 rn)))
            (if (== size 0)
                (= (gpr32 rd) (+ (gpr32 rm) (u32 1)))
                (= (gpr64 rd) (+ (gpr64 rm) 1))))))

(def CSINV
    "s 1 0 11010100 mmmmm cccc 0 0 nnnnn ddddd"
    "csinv $r$rd, $r$rn, $r$rm, $condstr"
    (names (size s) (rm m) (cond c) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 rd) (gpr32 rn))
                (= (gpr64 rd) (gpr64 rn)))
            (if (== size 0)
                (= (gpr32 rd) (~ (gpr32 rm)))
                (= (gpr64 rd) (~ (gpr64 rm)))))))

(def CSNEG
    "s 1 0 11010100 mmmmm cccc 0 1 nnnnn ddddd"
    "csneg $r$rd, $r$rn, $r$rm, $condstr"
    (names (size s) (rm m) (cond c) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 rd) (gpr32 rn))
                (= (gpr64 rd) (gpr64 rn)))
            (if (== size 0)
                (= (gpr32 rd) (u32 (-! (i32 (gpr32 rm)))))
                (= (gpr64 rd) (u64 (-! (i64 (gpr64 rm)))))))))

(def DMB
    "1101010100 0 00 011 0011 mmmm 1 01 11111"
    "DMB $option"
    (names (m m))
    (let option (match m
        0b1111 "SY"
        0b1110 "ST"
        0b1101 "LD"
        0b1011 "ISH"
        0b1010 "ISHST"
        0b1001 "ISHLD"
        0b0111 "NSH"
        0b0110 "NSHST"
        0b0101 "NSHLD"
        0b0011 "OSH"
        0b0010 "OSHST"
        "OSHLD"))
    (block))

(def DSB
    "1101010100 0 00 011 0011 mmmm 1 00 11111"
    "DSB $option"
    (names (crm m))
    (let option (match crm
        0b1111 "SY"
        0b1110 "ST"
        0b1101 "LD"
        0b1011 "ISH"
        0b1010 "ISHST"
        0b1001 "ISHLD"
        0b0111 "NSH"
        0b0110 "NSHST"
        0b0101 "NSHLD"
        0b0011 "OSH"
        0b0010 "OSHST"
        "OSHLD"))
    (block))

(def DUP-element-scalar
    "01 0 11110000 iiiii 0 0000 1 nnnnn ddddd"
    "dup $T$rd, V$rn.$T[$index]"
    (names (imm i) (rn n) (rd d))
    (mlet (T "" index 0 size 0)
        (if (== (& imm 0b01111) 0) (unimplemented)
        (if (== (& imm 0b00001) 0b00001) (block (= T "B") (= index (>> imm 1)) (= size 1))
        (if (== (& imm 0b00011) 0b00010) (block (= T "H") (= index (>> imm 2)) (= size 2))
        (if (== (& imm 0b00111) 0b00100) (block (= T "S") (= index (>> imm 3)) (= size 4))
                                         (block (= T "D") (= index (>> imm 4)) (= size 8)))))))
    (let sv (vec rn)
        (match size
            1 (= (vec-b rd) (vector-element sv index u8))
            2 (= (vec-h rd) (vector-element sv index u16))
            4 (= (vec-s rd) (vector-element sv index f32))
              (= (vec-d rd) (vector-element sv index f64)))))

(def DUP-element-vector
    "0 Q 0 01110000 iiiii 0 0000 1 nnnnn ddddd"
    "dup V$rd.$T, V$rn.$Ts[$index]"
    (names (Q Q) (imm i) (rn n) (rd d))
    (mlet (Ts "" T "" index 0 size 0)
        (if (== (& imm 0b01111) 0) (unimplemented)
        (if (== (& imm 0b00001) 0b00001) (block (= Ts "B") (= T (if Q "16B" "8B")) (= index (>> imm 1)) (= size 1))
        (if (== (& imm 0b00011) 0b00010) (block (= Ts "H") (= T (if Q "8H" "4H")) (= index (>> imm 2)) (= size 2))
        (if (== (& imm 0b00111) 0b00100) (block (= Ts "S") (= T (if Q "4S" "2S")) (= index (>> imm 3)) (= size 4))
                                         (block (= Ts "D") (= T (if Q "2D" (unimplemented))) (= index (>> imm 4)) (= size 8)))))))
    (let sv (vec rn)
        (let tv (match size
            1 (vector-all (vector-element sv index u8))
            2 (vector-all (vector-element sv index u16))
            4 (vector-all (vector-element sv index f32))
              (vector-all (vector-element sv index f64))))
        (= (vec rd) (if Q tv (vector-zero-top tv)))))

(def DUP-general
    "0 p 0 01110000 iiiii 0 0001 1 nnnnn ddddd"
    "dup V$rd.$T, $r$rn"
    (names (Q p) (imm i) (rn n) (rd d))
    (block
        (let size (if (== (& imm 0b01111) 0) (unimplemented) (if (== (& imm 0b01111) 0b01000) 64 32)))
        (let r (if (== size 64) "X" "W"))
        (let T
            (if (== (& imm 0b01111) 0) (unimplemented)
            (if (== (& imm 0b00001) 0b0001) (if Q "16B" "8B")
            (if (== (& imm 0b00011) 0b0010) (if Q "8H" "4H")
            (if (== (& imm 0b00111) 0b0100) (if Q "4S" "2S")
            (if Q "2D" (unimplemented))))))))
    (let src (gpr64 rn)
        (= (vec rd)
            (if (== (& imm 0b00001) 0b0001) (if Q
                (vector-all (u8 src))
                (vector-zero-top (vector-all (u8 src))))
            (if (== (& imm 0b00011) 0b0010) (if Q
                (vector-all (u16 src))
                (vector-zero-top (vector-all (u16 src))))
            (if (== (& imm 0b00111) 0b0100) (if Q
                (vector-all (u32 src))
                (vector-zero-top (vector-all (u32 src))))
            (if Q (vector-all src) (unimplemented))))))))

(def EON-shifted-register
    "f 10 01010 ss 1 mmmmm iiiiii nnnnn ddddd"
    "eon $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm (if size 63 31)))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
        (= (gpr32 rd) (^ (gpr32 rn) (~ (do-shift32 (gpr32 rm) shift imm))))
        (= (gpr64 rd) (^ (gpr64 rn) (~ (do-shift64 (gpr64 rm) shift imm))))))

(def EOR-immediate
    "f 10 100100 u iiiiii ssssss nnnnn ddddd"
    "and $r$rd, $r$rn, #$imm"
    (names (size f) (up u) (immr i) (imms s) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (make-wmask up imms immr 1 (if (== size 0) 32 64))))
    (if (== size 0)
        (= (gpr-or-sp32 rd) (^ (gpr32 rn) (u32 imm)))
        (= (gpr-or-sp64 rd) (^ (gpr64 rn) imm))))

(def EOR-shifted-register
    "f 10 01010 ss 0 mmmmm iiiiii nnnnn ddddd"
    "eor $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm (if size 63 31)))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
        (= (gpr32 rd) (^ (gpr32 rn) (do-shift32 (gpr32 rm) shift imm)))
        (= (gpr64 rd) (^ (gpr64 rn) (do-shift64 (gpr64 rm) shift imm)))))

(def EOR-vector
    "0 Q 1 01110 00 1 mmmmm 00011 1 nnnnn ddddd"
    "eor V$rd.$T, V$rn.$T, V$rm.$T"
    (names (Q Q) (rm m) (rn n) (rd d))
    (let T (if Q "16B" "8B"))
    (let v (vec^ (vec rn) (vec rm))
        (= (vec rd) (if Q v (vector-zero-top v)))))

(def EXT
    "0 Q 101110 00 0 mmmmm 0 iiii 0 nnnnn ddddd"
    "ext V$rd.$ts, V$rn.$ts, V$rm.$ts, #$index"
    (names (Q Q) (rm m) (index i) (rn n) (rd d))
    (let ts (if Q "16B" "8B"))
    (= (vec rd) (vector-extract (vec rn) (vec rm) Q index)))

(def EXTR
    "f 00 100111 o 0 mmmmm ssssss nnnnn ddddd"
    "extr $r$rd, $r$rn, $r$rm, #$lsb"
    (names (size f) (o o) (rm m) (lsb s) (rn n) (rd d))
    (block
        (requires (<= lsb (if size 63 31)))
        (requires (== size o))
        (let r (if (== size 0) "W" "X")))
    (if (== size 0)
        (= (gpr32 rd) (| (<< (gpr32 rn) (- 32 lsb)) (>> (gpr32 rm) lsb)))
        (= (gpr64 rd) (| (<< (gpr64 rn) (- 64 lsb)) (>> (gpr64 rm) lsb)))))

(def FABD-scalar
    "01 1 11110 1 s 1 mmmmm 11010 1 nnnnn ddddd"
    "fabd $r$rd, $r$rn, $r$rm"
    (names (size s) (rm m) (rn n) (rd d))
    (let r (match size
        0b0 "S"
        0b1 "D"
        (unimplemented)))
    (match size
        0b0 (= (vec-s rd) (abs (- (vec-s rn) (vec-s rm))))
        0b1 (= (vec-d rd) (abs (- (vec-d rn) (vec-d rm))))
        (unimplemented)))

(def FABS-scalar
    "0 0 0 11110 tt 1 0000 01 10000 nnnnn ddddd"
    "fabs $r$rd, $r$rn"
    (names (type t) (rn n) (rd d))
    (let r (match type
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (abs (vec-s rn)))
        0b01 (= (vec-d rd) (abs (vec-d rn)))
        (unimplemented)))

(def FABS-vector
    "0 Q 0 01110 1 s 10000 01111 10 nnnnn ddddd"
    "fabs V$rd.$t, V$rn.$t"
    (names (Q Q) (size s) (rn n) (rd d))
    (let t (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (match (: size Q)
        0b00 (mlet (a (vector-element (vec rn) 0 f32) b (vector-element (vec rn) 1 f32))
            (= (vec rd) (vector-all (f32 0)))
            (vector-insert rd 0 (abs a))
            (vector-insert rd 1 (abs b)))
        0b01 (mlet (
                a (vector-element (vec rn) 0 f32) b (vector-element (vec rn) 1 f32)
                c (vector-element (vec rn) 2 f32) d (vector-element (vec rn) 3 f32))
            (= (vec rd) (vector-all (f32 0)))
            (vector-insert rd 0 (abs a))
            (vector-insert rd 1 (abs b))
            (vector-insert rd 2 (abs c))
            (vector-insert rd 3 (abs d)))
        0b11 (mlet (a (vector-element (vec rn) 0 f64) b (vector-element (vec rn) 1 f64))
            (= (vec rd) (vector-all (f64 0)))
            (vector-insert rd 0 (abs a))
            (vector-insert rd 1 (abs b)))
        (unimplemented)))

(def FADD-scalar
    "0 0 0 11110 tt 1 mmmmm 001 0 10 nnnnn ddddd"
    "fadd $r$rd, $r$rn, $r$rm"
    (names (type t) (rm m) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b11 (with-fp16 (= (vec-h rd) (u16 (+ (vec-h rn) (vec-h rm)))))
        0b00 (= (vec-s rd) (+ (vec-s rn) (vec-s rm)))
        0b01 (= (vec-d rd) (+ (vec-d rn) (vec-d rm)))
        (unimplemented)))

(def FADD-vector
    "0 Q 0 01110 0 s 1 mmmmm 11010 1 nnnnn ddddd"
    "fadd V$rd.$ts, V$rn.$ts, V$rm.$ts"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let ts (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (match (: size Q)
        0b00 (= (vec rd) (vector-zero-top (vec+ (vec rn) (vec rm) 32)))
        0b01 (= (vec rd) (vec+ (vec rn) (vec rm) 32))
        0b11 (= (vec rd) (vec+ (vec rn) (vec rm) 64))
        (unimplemented)))

(def FADDP-scalar
    "01 1 11110 0 s 11000 01101 10 nnnnn ddddd"
    "faddp $r$rd, V$rn.2$r"
    (names (size s) (rn n) (rd d))
    (let r (if (== size 0) "S" "D"))
    (if (== size 0)
        (= (vec-s rd) (+ (vector-element (vec rn) 0 f32) (vector-element (vec rn) 1 f32)))
        (= (vec-d rd) (+ (vector-element (vec rn) 0 f64) (vector-element (vec rn) 1 f64)))))

(def FADDP-vector
    "0 Q 1 01110 0 s 1 mmmmm 11010 1 nnnnn ddddd"
    "faddp V$rd.$t, V$rn.$t, V$rm.$t"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let t (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (block
        (match (: size Q)
            0b00 (mlet (
                    a (vector-element (vec rn) 0 f32) b (vector-element (vec rn) 1 f32)
                    c (vector-element (vec rm) 0 f32) d (vector-element (vec rm) 1 f32))
                (= (vec rd) (vector-all (f32 0)))
                (vector-insert rd 0 (+ a b))
                (vector-insert rd 1 (+ c d)))
            0b01 (mlet (
                    a (vector-element (vec rn) 0 f32) b (vector-element (vec rn) 1 f32)
                    c (vector-element (vec rn) 2 f32) d (vector-element (vec rn) 3 f32)
                    e (vector-element (vec rm) 0 f32) f (vector-element (vec rm) 1 f32)
                    g (vector-element (vec rm) 2 f32) h (vector-element (vec rm) 3 f32))
                (= (vec rd) (vector-all (f32 0)))
                (vector-insert rd 0 (+ a b))
                (vector-insert rd 1 (+ c d))
                (vector-insert rd 2 (+ e f))
                (vector-insert rd 3 (+ g h)))
            0b11 (mlet (
                    a (vector-element (vec rn) 0 f64) b (vector-element (vec rn) 1 f64)
                    c (vector-element (vec rm) 0 f64) d (vector-element (vec rm) 1 f64))
                (= (vec rd) (vector-all (f32 0)))
                (vector-insert rd 0 (+ a b))
                (vector-insert rd 1 (+ c d)))
            (unimplemented))))

(def FCCMP
    "0 0 0 11110 tt 1 mmmmm cccc 01 nnnnn 0 vvvv"
    "fccmp $r$rn, $r$rm, #$nzcv, $condstr"
    (names (type t) (rm m) (rn n) (nzcv v) (cond c))
    (block
        (let r (match type
            0b11 "H"
            0b00 "S"
            0b01 "D"
            (unimplemented)))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (match type
                0b00 (fcmp (vec-s rn) (vec-s rm))
                0b01 (fcmp (vec-d rn) (vec-d rm))
                (unimplemented))
            (= (nzcv) (<< (u64 nzcv) 28)))))

(defm fcm-reg (a b itype ftype)
    (match (: E U ac)
        0b000 (if (== a b) (bitcast (itype -1) ftype) (bitcast (itype 0) ftype))
        0b010 (if (>= a b) (bitcast (itype -1) ftype) (bitcast (itype 0) ftype))
        0b011 (if (>= (abs a) (abs b)) (bitcast (itype -1) ftype) (bitcast (itype 0) ftype))
        0b110 (if (>  a b) (bitcast (itype -1) ftype) (bitcast (itype 0) ftype))
        0b111 (if (>  (abs a) (abs b)) (bitcast (itype -1) ftype) (bitcast (itype 0) ftype))
        (unimplemented)))

(def FCMxx-register-vector
    "0 Q U 01110 E s 1 mmmmm 1110 a 1 nnnnn ddddd"
    "FCM$top V$rd.$t, V$rn.$t, V$rm.$t"
    (names (Q Q) (U U) (E E) (size s) (rm m) (ac a) (rn n) (rd d))
    (block
        (let top (match (: E U ac)
            0b000 "EQ"
            0b010 "GE"
            0b011 "GE"
            0b110 "GT"
            0b111 "GT"
            (unimplemented)))
        (let t (match (: size Q)
            0b00 "2S"
            0b01 "4S"
            0b11 "2D"
            (unimplemented))))
    (match (: size Q)
        0b00 (let a1 (vector-element (vec rn) 0 f32) (let a2 (vector-element (vec rn) 1 f32)
            (let b1 (vector-element (vec rm) 0 f32) (let b2 (vector-element (vec rm) 1 f32)
                (= (vec rd) (vector-all (i32 0)))
                (vector-insert rd 0 (fcm-reg a1 b1 i32 f32))
                (vector-insert rd 1 (fcm-reg a2 b2 i32 f32))))))
        0b01 (let a1 (vector-element (vec rn) 0 f32) (let a2 (vector-element (vec rn) 1 f32)
            (let a3 (vector-element (vec rn) 2 f32) (let a4 (vector-element (vec rn) 3 f32)
            (let b1 (vector-element (vec rm) 0 f32) (let b2 (vector-element (vec rm) 1 f32)
            (let b3 (vector-element (vec rm) 2 f32) (let b4 (vector-element (vec rm) 3 f32)
                (= (vec rd) (vector-all (i32 0)))
                (vector-insert rd 0 (fcm-reg a1 b1 i32 f32))
                (vector-insert rd 1 (fcm-reg a2 b2 i32 f32))
                (vector-insert rd 2 (fcm-reg a3 b3 i32 f32))
                (vector-insert rd 3 (fcm-reg a4 b4 i32 f32))))))))))
        0b11 (let a1 (vector-element (vec rn) 0 f64) (let a2 (vector-element (vec rn) 1 f64)
             (let b1 (vector-element (vec rm) 0 f64) (let b2 (vector-element (vec rm) 1 f64)
                 (= (vec rd) (vector-all (i32 0)))
                 (vector-insert rd 0 (fcm-reg a1 b1 i64 f64))
                 (vector-insert rd 1 (fcm-reg a2 b2 i64 f64))))))
        (unimplemented)))

(defm fcm-zero (a b itype ftype)
    (match (: op U)
        0b00 (if (>  a b) (bitcast (itype -1) ftype) (bitcast (itype 0) ftype))
        0b01 (if (>= a b) (bitcast (itype -1) ftype) (bitcast (itype 0) ftype))
        0b10 (if (== a b) (bitcast (itype -1) ftype) (bitcast (itype 0) ftype))
             (if (<= a b) (bitcast (itype -1) ftype) (bitcast (itype 0) ftype))))

(def FCMxx-zero-vector
    "0 Q U 01110 1 s 10000 0110 o 10 nnnnn ddddd"
    "FCM$top V$rd.$t, V$rn.$t, #0.0"
    (names (Q Q) (U U) (size s) (op o) (rn n) (rd d))
    (block
        (let top (match (: op U)
            0b00 "GT"
            0b01 "GE"
            0b10 "EQ"
            "LE"))
        (let t (match (: size Q)
            0b00 "2S"
            0b01 "4S"
            0b11 "2D"
            (unimplemented))))
    (match (: size Q)
        0b00 (let v1 (vector-element (vec rn) 0 f32) (let v2 (vector-element (vec rn) 1 f32)
            (= (vec rd) (vector-all (i32 0)))
            (vector-insert rd 0 (fcm-zero v1 (f32 0) i32 f32))
            (vector-insert rd 1 (fcm-zero v2 (f32 0) i32 f32))))
        0b01 (let v1 (vector-element (vec rn) 0 f32) (let v2 (vector-element (vec rn) 1 f32)
            (let v3 (vector-element (vec rn) 2 f32) (let v4 (vector-element (vec rn) 3 f32)
                (= (vec rd) (vector-all (i32 0)))
                (vector-insert rd 0 (fcm-zero v1 (f32 0) i32 f32))
                (vector-insert rd 1 (fcm-zero v2 (f32 0) i32 f32))
                (vector-insert rd 2 (fcm-zero v3 (f32 0) i32 f32))
                (vector-insert rd 3 (fcm-zero v4 (f32 0) i32 f32))))))
        0b11 (let v1 (vector-element (vec rn) 0 f64) (let v2 (vector-element (vec rn) 1 f64)
            (= (vec rd) (vector-all (i32 0)))
            (vector-insert rd 0 (fcm-zero v1 (f64 0) i64 f64))
            (vector-insert rd 1 (fcm-zero v2 (f64 0) i64 f64))))
        (unimplemented)))

(defm fcmlt-zero (a b itype ftype)
    (if (< a b) (bitcast (itype -1) ftype) (bitcast (itype 0) ftype)))

(def FCMLT-zero-vector
    "0 Q 0 01110 1 s 10000 01110 10 nnnnn ddddd"
    "FCMLT V$rd.$t, V$rn.$t, #0.0"
    (names (Q Q) (size s) (rn n) (rd d))
    (let t (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (match (: size Q)
        0b00 (let v1 (vector-element (vec rn) 0 f32) (let v2 (vector-element (vec rn) 1 f32)
            (= (vec rd) (vector-all (i32 0)))
            (vector-insert rd 0 (fcmlt-zero v1 (f32 0) i32 f32))
            (vector-insert rd 1 (fcmlt-zero v2 (f32 0) i32 f32))))
        0b01 (let v1 (vector-element (vec rn) 0 f32) (let v2 (vector-element (vec rn) 1 f32)
            (let v3 (vector-element (vec rn) 2 f32) (let v4 (vector-element (vec rn) 3 f32)
                (= (vec rd) (vector-all (i32 0)))
                (vector-insert rd 0 (fcmlt-zero v1 (f32 0) i32 f32))
                (vector-insert rd 1 (fcmlt-zero v2 (f32 0) i32 f32))
                (vector-insert rd 2 (fcmlt-zero v3 (f32 0) i32 f32))
                (vector-insert rd 3 (fcmlt-zero v4 (f32 0) i32 f32))))))
        0b11 (let v1 (vector-element (vec rn) 0 f64) (let v2 (vector-element (vec rn) 1 f64)
            (= (vec rd) (vector-all (i32 0)))
            (vector-insert rd 0 (fcmlt-zero v1 (f64 0) i64 f64))
            (vector-insert rd 1 (fcmlt-zero v2 (f64 0) i64 f64))))
        (unimplemented)))

(def FCMP
    "0 0 0 11110 tt 1 mmmmm 00 1000 nnnnn 0o 000"
    "fcmp $r$rn, $r$rm $zero"
    (names (type t) (rm m) (rn n) (opc o))
    (block
        (let r (match type
            0b11 "H"
            0b00 "S"
            0b01 "D"
            (unimplemented)))
        (let zero (if (== opc 1) "/0" "")))
    (match type
        0b00 (fcmp (vec-s rn) (if (== opc 1) (f32 0) (vec-s rm)))
        0b01 (fcmp (vec-d rn) (if (== opc 1) (f64 0) (vec-d rm)))
        (unimplemented)))

(def FCSEL
    "0 0 0 11110 tt 1 mmmmm cccc 11 nnnnn ddddd"
    "fcsel $r$rd, $r$rn, $r$rm, $condstr"
    (names (type t) (rm m) (cond c) (rn n) (rd d))
    (block
        (let r (match type
            0b00 "S"
            0b01 "D"
            (unimplemented)))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (match type
                0b00 (= (vec-s rd) (vec-s rn))
                0b01 (= (vec-d rd) (vec-d rn))
                (unimplemented))
            (match type
                0b00 (= (vec-s rd) (vec-s rm))
                0b01 (= (vec-d rd) (vec-d rm))
                (unimplemented)))))

(def FCVT
    "0 0 0 11110 tt 1 0001 oo 10000 nnnnn ddddd"
    "fcvt $r1$rd, $r2$rn"
    (names (type t) (opc o) (rn n) (rd d))
    (block
        (let r1 "") (let r2 "")
        (let tf (: type opc))
        (match tf
            0b1100 (block (= r1 "S") (= r2 "H"))
            0b1101 (block (= r1 "D") (= r2 "H"))
            0b0011 (block (= r1 "H") (= r2 "S"))
            0b0001 (block (= r1 "D") (= r2 "S"))
            0b0111 (block (= r1 "H") (= r2 "D"))
            0b0100 (block (= r1 "S") (= r2 "D"))
            (unimplemented)))
    (match tf
        0b1100 (with-fp16 (= (vec-s rd) (f32 (vec-h rn))))
        0b1101 (with-fp16 (= (vec-d rd) (f64 (vec-h rn))))
        0b0011 (= (vec-h rd) (u16 (vec-s rn)))
        0b0001 (= (vec-d rd) (f64 (vec-s rn)))
        0b0111 (= (vec-h rd) (u16 (vec-d rn)))
        0b0100 (= (vec-s rd) (f32 (vec-d rn)))
        (unimplemented)))

(defm fcvtas-sub (v) (if (>= v 0) (round-half-up v) (round-half-down v)))

(def FCVTAS-scalar-integer
    "s 0 0 11110 tt 1 00 100 000000 nnnnn ddddd"
    "fcvtas $r1$rd, $r2$rn"
    (names (size s) (type t) (rn n) (rd d))
    (block
        (let st (: size type))
        (let r1 "") (let r2 "")
        (match st
            0b0_11 (block (= r1 "W") (= r2 "H"))
            0b1_11 (block (= r1 "X") (= r2 "H"))
            0b0_00 (block (= r1 "W") (= r2 "S"))
            0b1_00 (block (= r1 "X") (= r2 "S"))
            0b0_01 (block (= r1 "W") (= r2 "D"))
            0b1_01 (block (= r1 "X") (= r2 "D"))
            (unimplemented)))
    (match st
        0b0_00 (= (gpr32 rd) (bitcast (i32 (fcvtas-sub (vec-s rn))) u32))
        0b1_00 (= (gpr64 rd) (bitcast (i64 (fcvtas-sub (vec-s rn))) u64))
        0b0_01 (= (gpr32 rd) (bitcast (i32 (fcvtas-sub (vec-d rn))) u32))
        0b1_01 (= (gpr64 rd) (bitcast (i64 (fcvtas-sub (vec-d rn))) u64))
        (unimplemented)))

(def FCVTAU-scalar-integer
    "s 0 0 11110 tt 1 00 101 000000 nnnnn ddddd"
    "fcvtau $r1$rd, $r2$rn"
    (names (size s) (type t) (rn n) (rd d))
    (block
        (let st (: size type))
        (let r1 "") (let r2 "")
        (match st
            0b0_11 (block (= r1 "W") (= r2 "H"))
            0b1_11 (block (= r1 "X") (= r2 "H"))
            0b0_00 (block (= r1 "W") (= r2 "S"))
            0b1_00 (block (= r1 "X") (= r2 "S"))
            0b0_01 (block (= r1 "W") (= r2 "D"))
            0b1_01 (block (= r1 "X") (= r2 "D"))
            (unimplemented)))
    (match st
        0b0_00 (= (gpr32 rd) (u32 (fcvtas-sub (vec-s rn))))
        0b1_00 (= (gpr64 rd) (u64 (fcvtas-sub (vec-s rn))))
        0b0_01 (= (gpr32 rd) (u32 (fcvtas-sub (vec-d rn))))
        0b1_01 (= (gpr64 rd) (u64 (fcvtas-sub (vec-d rn))))
        (unimplemented)))

(def FCVTL[2]
    "0 Q 0 01110 0 s 10000 10111 10 nnnnn ddddd"
    "fcvtl$o2 V$rd.$ta, V$rn.$tb"
    (names (Q Q) (size s) (rn n) (rd d))
    (block
        (let o2 (if Q "2" ""))
        (let ta (if size "2D" "4S"))
        (let tb (match (: size Q)
            0b00 "4H"
            0b01 "8H"
            0b10 "2S"
            "4S")))
    (let n (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (match (: size Q)
            0b10 (block
                    (vector-insert rd 0 (f64 (vector-element n 0 f32)))
                    (vector-insert rd 1 (f64 (vector-element n 1 f32))))
            0b11 (block
                    (vector-insert rd 0 (f64 (vector-element n 2 f32)))
                    (vector-insert rd 1 (f64 (vector-element n 3 f32))))
            (unimplemented))))

(def FCVTMS-scalar-integer
    "s 0 0 11110 tt 1 10 000 000000 nnnnn ddddd"
    "fcvtms $r1$rd, $r2$rn"
    (names (size s) (type t) (rn n) (rd d))
    (block
        (let st (: size type))
        (let r1 "") (let r2 "")
        (match st
            0b0_11 (block (= r1 "W") (= r2 "H"))
            0b1_11 (block (= r1 "X") (= r2 "H"))
            0b0_00 (block (= r1 "W") (= r2 "S"))
            0b1_00 (block (= r1 "X") (= r2 "S"))
            0b0_01 (block (= r1 "W") (= r2 "D"))
            0b1_01 (block (= r1 "X") (= r2 "D"))
            (unimplemented)))
    (match st
        0b0_00 (= (gpr32 rd) (bitcast (i32 (floor (vec-s rn))) u32))
        0b1_00 (= (gpr64 rd) (bitcast (i64 (floor (vec-s rn))) u64))
        0b0_01 (= (gpr32 rd) (bitcast (i32 (floor (vec-d rn))) u32))
        0b1_01 (= (gpr64 rd) (bitcast (i64 (floor (vec-d rn))) u64))
        (unimplemented)))

(def FCVTMU-scalar-integer
    "s 0 0 11110 tt 1 10 001 000000 nnnnn ddddd"
    "fcvtmu $r1$rd, $r2$rn"
    (names (size s) (type t) (rn n) (rd d))
    (block
        (let st (: size type))
        (let r1 "") (let r2 "")
        (match st
            0b0_11 (block (= r1 "W") (= r2 "H"))
            0b1_11 (block (= r1 "X") (= r2 "H"))
            0b0_00 (block (= r1 "W") (= r2 "S"))
            0b1_00 (block (= r1 "X") (= r2 "S"))
            0b0_01 (block (= r1 "W") (= r2 "D"))
            0b1_01 (block (= r1 "X") (= r2 "D"))
            (unimplemented)))
    (match st
        0b0_00 (= (gpr32 rd) (u32 (i32 (floor (vec-s rn)))))
        0b1_00 (= (gpr64 rd) (u64 (i64 (floor (vec-s rn)))))
        0b0_01 (= (gpr32 rd) (u32 (i32 (floor (vec-d rn)))))
        0b1_01 (= (gpr64 rd) (u64 (i64 (floor (vec-d rn)))))
        (unimplemented)))

(def FCVTN
    "0 0 0 01110 0 s 10000 10110 10 nnnnn ddddd"
    "fcvtn V$rd.$Tb, V$rn.$Ta"
    (names (size s) (rn n) (rd d))
    (mlet (Ta "" Tb "")
        (match size
            0 (block (= Ta "4S") (= Tb "4H"))
            1 (block (= Ta "2D") (= Tb "2S"))))
    (let sv (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (match size
            0 (block
                (vector-insert rd 0 (i16 (vector-element sv 0 f32)))
                (vector-insert rd 1 (i16 (vector-element sv 1 f32)))
                (vector-insert rd 2 (i16 (vector-element sv 2 f32)))
                (vector-insert rd 3 (i16 (vector-element sv 3 f32))))
            1 (block
                (vector-insert rd 0 (f32 (vector-element sv 0 f64)))
                (vector-insert rd 1 (f32 (vector-element sv 1 f64)))))))

(def FCVTN2
    "0 1 0 01110 0 s 10000 10110 10 nnnnn ddddd"
    "fcvtn2 V$rd.$Tb, V$rn.$Ta"
    (names (size s) (rn n) (rd d))
    (mlet (Ta "" Tb "")
        (match size
            0 (block (= Ta "4S") (= Tb "8H"))
            1 (block (= Ta "2D") (= Tb "4S"))))
    (let sv (vec rn)
        (match size
            0 (block
                (vector-insert rd 4 (i16 (vector-element sv 0 f32)))
                (vector-insert rd 5 (i16 (vector-element sv 1 f32)))
                (vector-insert rd 6 (i16 (vector-element sv 2 f32)))
                (vector-insert rd 7 (i16 (vector-element sv 3 f32))))
            1 (block
                (vector-insert rd 2 (f32 (vector-element sv 0 f64)))
                (vector-insert rd 3 (f32 (vector-element sv 1 f64)))))))

(def FCVTPS-scalar-integer
    "s 0 0 11110 tt 1 01 000 000000 nnnnn ddddd"
    "fcvtps $r1$rd, $r2$rn"
    (names (size s) (type t) (rn n) (rd d))
    (block
        (let st (: size type))
        (let r1 "") (let r2 "")
        (match st
            0b0_11 (block (= r1 "W") (= r2 "H"))
            0b1_11 (block (= r1 "X") (= r2 "H"))
            0b0_00 (block (= r1 "W") (= r2 "S"))
            0b1_00 (block (= r1 "X") (= r2 "S"))
            0b0_01 (block (= r1 "W") (= r2 "D"))
            0b1_01 (block (= r1 "X") (= r2 "D"))
            (unimplemented)))
    (match st
        0b0_00 (= (gpr32 rd) (i32 (ceil (vec-s rn))))
        0b1_00 (= (gpr64 rd) (i64 (ceil (vec-s rn))))
        0b0_01 (= (gpr32 rd) (i32 (ceil (vec-d rn))))
        0b1_01 (= (gpr64 rd) (i64 (ceil (vec-d rn))))
        (unimplemented)))

(def FCVTPU-scalar-integer
    "s 0 0 11110 tt 1 01 001 000000 nnnnn ddddd"
    "fcvtpu $r1$rd, $r2$rn"
    (names (size s) (type t) (rn n) (rd d))
    (block
        (let st (: size type))
        (let r1 "") (let r2 "")
        (match st
            0b0_11 (block (= r1 "W") (= r2 "H"))
            0b1_11 (block (= r1 "X") (= r2 "H"))
            0b0_00 (block (= r1 "W") (= r2 "S"))
            0b1_00 (block (= r1 "X") (= r2 "S"))
            0b0_01 (block (= r1 "W") (= r2 "D"))
            0b1_01 (block (= r1 "X") (= r2 "D"))
            (unimplemented)))
    (match st
        0b0_00 (= (gpr32 rd) (u32 (i32 (ceil (vec-s rn)))))
        0b1_00 (= (gpr64 rd) (u64 (i64 (ceil (vec-s rn)))))
        0b0_01 (= (gpr32 rd) (u32 (i32 (ceil (vec-d rn)))))
        0b1_01 (= (gpr64 rd) (u64 (i64 (ceil (vec-d rn)))))
        (unimplemented)))

(def FCVTZS-scalar-fixedpoint
    "f 0 0 11110 tt 0 11 000 ssssss nnnnn ddddd"
    "fcvtzs $r1$rd, $r2$rn, #$fbits"
    (names (size f) (type t) (scale s) (rn n) (rd d))
    (block
        (let fbits (- 64 scale))
        (requires (<= fbits (if size 63 31)))
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (match type
            0b11 "H"
            0b00 "S"
            0b01 "D"
            (unimplemented))))
    (match (: size type)
        0b0_00 (= (gpr32 rd) (float-to-fixed-point (vec-s rn) u32 fbits))
        0b1_00 (= (gpr64 rd) (float-to-fixed-point (vec-s rn) u64 fbits))
        0b0_01 (= (gpr32 rd) (float-to-fixed-point (vec-d rn) u32 fbits))
        0b1_01 (= (gpr64 rd) (float-to-fixed-point (vec-d rn) u64 fbits))
        (unimplemented)))

(def FCVTZS-scalar-integer
    "s 0 0 11110 tt 1 11 000 000000 nnnnn ddddd"
    "fcvtzs $r1$rd, $r2$rn"
    (names (size s) (type t) (rn n) (rd d))
    (block
        (let st (: size type))
        (let r1 "") (let r2 "")
        (match st
            0b0_11 (block (= r1 "W") (= r2 "H"))
            0b1_11 (block (= r1 "X") (= r2 "H"))
            0b0_00 (block (= r1 "W") (= r2 "S"))
            0b1_00 (block (= r1 "X") (= r2 "S"))
            0b0_01 (block (= r1 "W") (= r2 "D"))
            0b1_01 (block (= r1 "X") (= r2 "D"))
            (unimplemented)))
    (match st
        0b0_00 (= (gpr32 rd) (u32 (i32 (vec-s rn))))
        0b1_00 (= (gpr64 rd) (u64 (i64 (vec-s rn))))
        0b0_01 (= (gpr32 rd) (u32 (i32 (vec-d rn))))
        0b1_01 (= (gpr64 rd) (u64 (i64 (vec-d rn))))
        (unimplemented)))

(def FCVTZU-scalar-fixedpoint
    "f 0 0 11110 tt 0 11 001 ssssss nnnnn ddddd"
    "fcvtzu $r1$rd, $r2$rn, #$fbits"
    (names (size f) (type t) (scale s) (rn n) (rd d))
    (block
        (let fbits (- 64 scale))
        (requires (<= fbits (if size 63 31)))
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (match type
            0b11 "H"
            0b00 "S"
            0b01 "D"
            (unimplemented))))
    (match (: size type)
        0b0_00 (= (gpr32 rd) (float-to-fixed-point (vec-s rn) u32 fbits))
        0b1_00 (= (gpr64 rd) (float-to-fixed-point (vec-s rn) u64 fbits))
        0b0_01 (= (gpr32 rd) (float-to-fixed-point (vec-d rn) u32 fbits))
        0b1_01 (= (gpr64 rd) (float-to-fixed-point (vec-d rn) u64 fbits))
        (unimplemented)))

(def FCVTZU-scalar-integer
    "s 0 0 11110 tt 1 11 001 000000 nnnnn ddddd"
    "fcvtzu $r1$rd, $r2$rn"
    (names (size s) (type t) (rn n) (rd d))
    (block
        (let st (: size type))
        (let r1 "") (let r2 "")
        (match st
            0b0_11 (block (= r1 "W") (= r2 "H"))
            0b1_11 (block (= r1 "X") (= r2 "H"))
            0b0_00 (block (= r1 "W") (= r2 "S"))
            0b1_00 (block (= r1 "X") (= r2 "S"))
            0b0_01 (block (= r1 "W") (= r2 "D"))
            0b1_01 (block (= r1 "X") (= r2 "D"))
            (unimplemented)))
    (match st
        0b0_00 (= (gpr32 rd) (u32 (vec-s rn)))
        0b1_00 (= (gpr64 rd) (u64 (vec-s rn)))
        0b0_01 (= (gpr32 rd) (u32 (vec-d rn)))
        0b1_01 (= (gpr64 rd) (u64 (vec-d rn)))
        (unimplemented)))

(def FDIV-scalar
    "0 0 0 11110 tt 1 mmmmm 0001 10 nnnnn ddddd"
    "fdiv $r$rd, $r$rn, $r$rm"
    (names (type t) (rm m) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b11 (unimplemented)
        0b00 (= (vec-s rd) (/ (vec-s rn) (vec-s rm)))
        0b01 (= (vec-d rd) (/ (vec-d rn) (vec-d rm)))
        (unimplemented)))

(def FDIV-vector
    "0 Q 1 01110 0 s 1 mmmmm 11111 1 nnnnn ddddd"
    "fdiv V$rd.$ts, V$rn.$ts, V$rm.$ts"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let ts (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (match (: size Q)
        0b00 (= (vec rd) (vector-zero-top (vec/ (vec rn) (vec rm) 32)))
        0b01 (= (vec rd) (vec/ (vec rn) (vec rm) 32))
        0b11 (= (vec rd) (vec/ (vec rn) (vec rm) 64))
        (unimplemented)))

(def FMADD
    "0 0 0 11111 tt 0 mmmmm 0 aaaaa nnnnn ddddd"
    "fmadd $t$rd, $t$rn, $t$rm, $t$ra"
    (names (type t) (rm m) (ra a) (rn n) (rd d))
    (let t (match type
                0b00 "S"
                0b01 "D"
                0b11 "H"
                (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (+ (* (vec-s rn) (vec-s rm)) (vec-s ra)))
        0b01 (= (vec-d rd) (+ (* (vec-d rn) (vec-d rm)) (vec-d ra)))
        (unimplemented)))

(def FMAX-scalar
    "0 0 0 11110 tt 1 mmmmm 01 00 10 nnnnn ddddd"
    "fmax $r$rd, $r$rn, $r$rm"
    (names (type t) (rm m) (rn n) (rd d))
    (let r (match type
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (mlet (a (vec-s rn) b (vec-s rm)) (= (vec-s rd) (if (| (NaN? a) (NaN? b)) (bitcast 0xFFFFFFFF f32) (if (> a b) a b))))
        0b01 (mlet (a (vec-d rn) b (vec-d rm)) (= (vec-d rd) (if (| (NaN? a) (NaN? b)) (bitcast 0xFFFFFFFF_FFFFFFFF f64) (if (> a b) a b))))
        (unimplemented)))

(def FMAXNM-scalar
    "0 0 0 11110 tt 1 mmmmm 01 10 10 nnnnn ddddd"
    "fmaxnm $r$rd, $r$rn, $r$rm"
    (names (type t) (rm m) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (let a (vec-s rn) (let b (vec-s rm) (= (vec-s rd) (if (NaN? a) b (if (NaN? b) a (if (> a b) a b))))))
        0b01 (let a (vec-d rn) (let b (vec-d rm) (= (vec-d rd) (if (NaN? a) b (if (NaN? b) a (if (> a b) a b))))))
        (unimplemented)))

(def FMIN-scalar
    "0 0 0 11110 tt 1 mmmmm 01 01 10 nnnnn ddddd"
    "fmin $r$rd, $r$rn, $r$rm"
    (names (type t) (rm m) (rn n) (rd d))
    (let r (match type
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (mlet (a (vec-s rn) b (vec-s rm)) (= (vec-s rd) (if (| (NaN? a) (NaN? b)) (bitcast 0xFFFFFFFF f32) (if (< a b) a b))))
        0b01 (mlet (a (vec-d rn) b (vec-d rm)) (= (vec-d rd) (if (| (NaN? a) (NaN? b)) (bitcast 0xFFFFFFFF_FFFFFFFF f64) (if (< a b) a b))))
        (unimplemented)))

(def FMINNM-scalar
    "0 0 0 11110 tt 1 mmmmm 01 11 10 nnnnn ddddd"
    "fminnm $r$rd, $r$rn, $r$rm"
    (names (type t) (rm m) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (let a (vec-s rn) (let b (vec-s rm) (= (vec-s rd) (if (NaN? a) b (if (NaN? b) a (if (< a b) a b))))))
        0b01 (let a (vec-d rn) (let b (vec-d rm) (= (vec-d rd) (if (NaN? a) b (if (NaN? b) a (if (< a b) a b))))))
        (unimplemented)))

(def FMLA-by-element-vector-spdp
    "0 Q 0 01111 1 s L mmmmm 0 0 01 H 0 nnnnn ddddd"
    "fmla V$rd.$T, V$rn.$T, V$rm.$Ts[$index]"
    (names (Q Q) (sz s) (L L) (rm m) (H H) (rn n) (rd d))
    (block
        (let T (match (: Q sz)
            0b00 "2S"
            0b10 "4S"
            0b11 "2D"
            (unimplemented)))
        (let Ts (if sz "D" "S"))
        (let index (match (: sz L)
            0b10 (u32 H)
            0b11 (unimplemented)
            (u32 (: H L)))))
    (let v (if sz
                (vec+ (vec rd) (vec* (vec rn) (vector-all (vector-element (vec rm) index f64)) 64) 64)
                (vec+ (vec rd) (vec* (vec rn) (vector-all (vector-element (vec rm) index f32)) 32) 32))
        (= (vec rd) (if Q v (vector-zero-top v)))))

(def FMLA-vector
    "0 Q 0 01110 0 s 1 mmmmm 11001 1 nnnnn ddddd"
    "fmla V$rd.$T, V$rn.$T, V$rm.$T"
    (names (Q Q) (sz s) (rm m) (rn n) (rd d))
    (let T (match (: sz Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (= (vec rd) (zero-if Q (if sz
        (vec+ (vec rd) (vec* (vec rn) (vec rm) 64) 64)
        (vec+ (vec rd) (vec* (vec rn) (vec rm) 32) 32)))))

(def FMLS-by-element-vector-spdp
    "0 Q 0 01111 1 s L mmmmm 0 1 01 H 0 nnnnn ddddd"
    "fmls V$rd.$T, V$rn.$T, V$rm.$Ts[$index]"
    (names (Q Q) (sz s) (L L) (rm m) (H H) (rn n) (rd d))
    (block
        (let T (match (: Q sz)
            0b00 "2S"
            0b10 "4S"
            0b11 "2D"
            (unimplemented)))
        (let Ts (if sz "D" "S"))
        (let index (match (: sz L)
            0b10 (u32 H)
            0b11 (unimplemented)
            (u32 (: H L)))))
    (= (vec rd) (zero-if Q (if sz
        (vec- (vec rd) (vec* (vec rn) (vector-all (vector-element (vec rm) index f64)) 64) 64)
        (vec- (vec rd) (vec* (vec rn) (vector-all (vector-element (vec rm) index f32)) 32) 32)))))

(def FMLS-vector
    "0 Q 0 01110 1 s 1 mmmmm 11001 1 nnnnn ddddd"
    "fmls V$rd.$T, V$rn.$T, V$rm.$T"
    (names (Q Q) (sz s) (rm m) (rn n) (rd d))
    (let T (match (: sz Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (= (vec rd) (zero-if Q (if sz
        (vec- (vec rd) (vec* (vec rn) (vec rm) 64) 64)
        (vec- (vec rd) (vec* (vec rn) (vec rm) 32) 32)))))

(def FMOV-general
    "f 0 0 11110 tt 1 0m 11o 000000 nnnnn ddddd"
    "fmov $r1$rd$index1, $r2$rn$index2"
    (names (sf f) (type t) (mode m) (ropc o) (rn n) (rd d))
    (block
        (let opc (: (cast 0b11 u2) ropc))
        (let tf (: sf type (cast mode u2) opc))
        (let r1 "") (let r2 "")
        (match tf
            0b0_11_00_110 (block (= r1 "W") (= r2 "H"))
            0b1_11_00_110 (block (= r1 "X") (= r2 "H"))
            0b0_11_00_111 (block (= r1 "H") (= r2 "W"))
            0b0_00_00_111 (block (= r1 "S") (= r2 "W"))
            0b0_00_00_110 (block (= r1 "W") (= r2 "S"))
            0b1_11_00_111 (block (= r1 "H") (= r2 "X"))
            0b1_01_00_111 (block (= r1 "D") (= r2 "X"))
            0b1_10_01_111 (block (= r1 "V") (= r2 "X"))
            0b1_10_01_110 (block (= r1 "X") (= r2 "V"))
            0b1_01_00_110 (block (= r1 "X") (= r2 "D"))
            (unimplemented))
        (let index1 (if (== r1 "V") ".D[1]" ""))
        (let index2 (if (== r2 "V") ".D[1]" "")))
    (match tf
        0b0_11_00_110 (= (gpr32 rd) (   cast (vec-h rn) u32))
        0b1_11_00_110 (= (gpr64 rd) (   cast (vec-h rn) u64))
        0b0_11_00_111 (= (vec-h rd) (   cast (gpr32 rn) u16))
        0b0_00_00_111 (= (vec-s rd) (bitcast (gpr32 rn) f32))
        0b0_00_00_110 (= (gpr32 rd) (bitcast (vec-s rn) u32))
        0b1_11_00_111 (= (vec-h rd) (   cast (gpr64 rn) u16))
        0b1_01_00_111 (= (vec-d rd) (bitcast (gpr64 rn) f64))
        0b1_01_00_110 (= (gpr64 rd) (bitcast (vec-d rn) u64))
        0b1_10_01_110 (= (gpr64 rd) (vector-element (vec rn) 1 u64))
        0b1_10_01_111 (vector-insert rd 1 (gpr64 rn))
        (unimplemented)))

(def FMOV-scalar-immediate
    "0 0 0 11110 tt 1 iiiiiiii 100 00000 ddddd"
    "fmov $r$rd, #$sv"
    (names (type t) (imm i) (rd d))
    (block
        (let r (match type
            0b11 "H"
            0b00 "S"
            0b01 "D"
            (unimplemented)))
        (let sv (bitcast (:
            (u1 (>> imm 7))
            (! (& (>> imm 6) 1))
            (replicate (u1 (& (>> imm 6) 1)) 5)
            (cast (& (>> imm 4) 0b11) u2)
            (cast (& imm 0b1111) u4)
            (replicate (u1 0) 19)) f32)))
    (match type
        0b00 (= (vec-s rd) sv)
        0b01 (= (vec-d rd)
            (bitcast (:
                (u1 (>> imm 7))
                (! (& (>> imm 6) 1))
                (replicate (u1 (& (>> imm 6) 1)) 8)
                (cast (& (>> imm 4) 0b11) u2)
                (cast (& imm 0b1111) u4)
                (replicate (u1 0) 48)) f64))))

(def FMOV-vector-immediate-single
    "0 Q 0 0111100000 a b c 1111 0 1 d e f g h ttttt"
    "fmov V$rd.$T, #$sv"
    (names (Q Q) (a a) (b b) (c c) (d d) (e e) (f f) (g g) (h h) (rd t))
    (block
        (let T (if Q "4S" "2S"))
        (let sv (bitcast (^ (:
            a b b b b b b c d e f g h (cast 0 u19)
        ) (<< (cast 1 u32) 30)) f32)))
    (let avec (vector-all sv)
        (if Q
            (= (vec rd) avec)
            (= (vec rd) (vector-zero-top avec)))))

(def FMOV-vector-immediate-double
    "0 1 1 0111100000 a b c 1111 0 1 d e f g h ttttt"
    "fmov V$rd.2D, #$sv"
    (names (a a) (b b) (c c) (d d) (e e) (f f) (g g) (h h) (rd t))
    (let sv (bitcast (^ (:
        a b b b b b b b b b c d e f g h (cast 0 u48)
    ) (<< (cast 1 u64) 62)) f64))
    (= (vec rd) (vector-all sv)))

(def FMSUB
    "0 0 0 11111 tt 0 mmmmm 1 aaaaa nnnnn ddddd"
    "fmsub $t$rd, $t$rn, $t$rm, $t$ra"
    (names (type t) (rm m) (ra a) (rn n) (rd d))
    (let t (match type
                0b00 "S"
                0b01 "D"
                0b11 "H"
                (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (- (vec-s ra) (* (vec-s rn) (vec-s rm))))
        0b01 (= (vec-d rd) (- (vec-d ra) (* (vec-d rn) (vec-d rm))))
        (unimplemented)))

(def FMUL-by-element-scalar-spdp
    "01 0 11111 1 s L mmmmm 1001 H 0 nnnnn ddddd"
    "fmul $Ts$rd, $Ts$rn, V$rm.$Ts[$index]"
    (names (Q Q) (sz s) (L L) (rm m) (H H) (rn n) (rd d))
    (block
        (let Ts (if sz "D" "S"))
        (let index
            (match (: sz L)
                0b10 (u32 H)
                0b11 (unimplemented)
                (u32 (: H L)))))
    (if sz
        (= (vec-d rd) (* (vec-d rn) (vector-element (vec rm) index f64)))
        (= (vec-s rd) (* (vec-s rn) (vector-element (vec rm) index f32)))))

(def FMUL-by-element-vector-spdp
    "0 Q 0 01111 1 s L mmmmm 1001 H 0 nnnnn ddddd"
    "fmul V$rd.$T, V$rn.$T, V$rm.$Ts[$index]"
    (names (Q Q) (sz s) (L L) (rm m) (H H) (rn n) (rd d))
    (block
        (let T (match (: Q sz)
            0b00 "2S"
            0b10 "4S"
            0b11 "2D"
            (unimplemented)))
        (let Ts (if sz "D" "S"))
        (let index
            (match (: sz L)
                0b10 (u32 H)
                0b11 (unimplemented)
                (u32 (: H L)))))
    (= (vec rd) (zero-if Q (if sz
        (vec* (vec rn) (vector-all (vector-element (vec rm) index f64)) 64)
        (vec* (vec rn) (vector-all (vector-element (vec rm) index f32)) 32)))))

(def FMUL-scalar
    "0 0 0 11110 tt 1 mmmmm 0 000 10 nnnnn ddddd"
    "fmul $r$rd, $r$rn, $r$rm"
    (names (type t) (rm m) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (* (vec-s rn) (vec-s rm)))
        0b01 (= (vec-d rd) (* (vec-d rn) (vec-d rm)))
        (unimplemented)))

(def FMUL-vector
    "0 Q 1 01110 0 s 1 mmmmm 11011 1 nnnnn ddddd"
    "fmul V$rd.$ts, V$rn.$ts, V$rm.$ts"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let ts (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (match (: size Q)
        0b00 (= (vec rd) (vector-zero-top (vec* (vec rn) (vec rm) 32)))
        0b01 (= (vec rd) (vec* (vec rn) (vec rm) 32))
        0b11 (= (vec rd) (vec* (vec rn) (vec rm) 64))
        (unimplemented)))

(def FNEG-scalar
    "0 0 0 11110 tt 1 0000 10 10000 nnnnn ddddd"
    "fneg $r$rd, $r$rn"
    (names (type t) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (-! (vec-s rn)))
        0b01 (= (vec-d rd) (-! (vec-d rn)))
        (unimplemented)))

(def FNEG-vector
    "0 Q 1 01110 1 s 10000 01111 10 nnnnn ddddd"
    "fneg V$rd.$T, V$rn.$T"
    (names (Q Q) (size s) (rn n) (rd d))
    (let T (match (: size Q)
        0b0_0 "2S"
        0b0_1 "4S"
        0b1_1 "2D"
        (unimplemented)))
    (let sv (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (match (: size Q)
            0b0_0 (block
                (vector-insert rd 0 (-! (vector-element sv 0 f32)))
                (vector-insert rd 1 (-! (vector-element sv 1 f32))))
            0b0_1 (block
                (vector-insert rd 0 (-! (vector-element sv 0 f32)))
                (vector-insert rd 1 (-! (vector-element sv 1 f32)))
                (vector-insert rd 2 (-! (vector-element sv 2 f32)))
                (vector-insert rd 3 (-! (vector-element sv 3 f32))))
            0b1_1 (block
                (vector-insert rd 0 (-! (vector-element sv 0 f64)))
                (vector-insert rd 1 (-! (vector-element sv 1 f64))))
            (unimplemented))))

(def FNMADD
    "0 0 0 11111 tt 1 mmmmm 0 aaaaa nnnnn ddddd"
    "fnmadd $r$rd, $r$rn, $r$rm, $r$ra"
    (names (type t) (rm m) (ra a) (rn n) (rd d))
    (let r (match type
            0b11 "H"
            0b00 "S"
            0b01 "D"
            (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (- (-! (* (vec-s rn) (vec-s rm))) (vec-s ra)))
        0b01 (= (vec-d rd) (- (-! (* (vec-d rn) (vec-d rm))) (vec-d ra)))
        (unimplemented)))

(def FNMSUB
    "0 0 0 11111 tt 1 mmmmm 1 aaaaa nnnnn ddddd"
    "fnmsub $r$rd, $r$rn, $r$rm, $r$ra"
    (names (type t) (rm m) (ra a) (rn n) (rd d))
    (let r (match type
            0b11 "H"
            0b00 "S"
            0b01 "D"
            (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (- (* (vec-s rn) (vec-s rm)) (vec-s ra)))
        0b01 (= (vec-d rd) (- (* (vec-d rn) (vec-d rm)) (vec-d ra)))
        (unimplemented)))

(def FNMUL-scalar
    "0 0 0 11110 tt 1 mmmmm 1 000 10 nnnnn ddddd"
    "fnmul $r$rd, $r$rn, $r$rm"
    (names (type t) (rm m) (rn n) (rd d))
    (let r (match type
            0b11 "H"
            0b00 "S"
            0b01 "D"
            (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (-! (* (vec-s rn) (vec-s rm))))
        0b01 (= (vec-d rd) (-! (* (vec-d rn) (vec-d rm))))
        (unimplemented)))

(defm frinta (v) (if (< v 0) (round-half-down v) (round-half-up v)))

(def FRINTA-scalar
    "0 0 0 11110 tt 1 001 100 10000 nnnnn ddddd"
    "frinta $r$rd, $r$rn"
    (names (type t) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (frinta (vec-s rn)))
        0b01 (= (vec-d rd) (frinta (vec-d rn)))
        (unimplemented)))

(def FRINTI-scalar
    "0 0 0 11110 tt 1 001 111 10000 nnnnn ddddd"
    "frinti $r$rd, $r$rn"
    (names (type t) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (round (vec-s rn)))
        0b01 (= (vec-d rd) (round (vec-d rn)))
        (unimplemented)))

(def FRINTM-scalar
    "0 0 0 11110 tt 1 001 010 10000 nnnnn ddddd"
    "frintm $r$rd, $r$rn"
    (names (type t) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (round-half-down (vec-s rn)))
        0b01 (= (vec-d rd) (round-half-down (vec-d rn)))
        (unimplemented)))

(def FRINTP-scalar
    "0 0 0 11110 tt 1 001 001 10000 nnnnn ddddd"
    "frintp $r$rd, $r$rn"
    (names (type t) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (round-half-up (vec-s rn)))
        0b01 (= (vec-d rd) (round-half-up (vec-d rn)))
        (unimplemented)))

(def FRINTX-scalar
    "0 0 0 11110 tt 1 001 110 10000 nnnnn ddddd"
    "frintx $r$rd, $r$rn"
    (names (type t) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (round (vec-s rn)))
        0b01 (= (vec-d rd) (round (vec-d rn)))
        (unimplemented)))

(def FRINTZ-scalar
    "0 0 0 11110 tt 1 001 011 10000 nnnnn ddddd"
    "frintz $r$rd, $r$rn"
    (names (type t) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (if (< (vec-s rn) 0) (round-half-up (vec-s rn)) (round-half-down (vec-s rn))))
        0b01 (= (vec-d rd) (if (< (vec-d rn) 0) (round-half-up (vec-d rn)) (round-half-down (vec-d rn))))
        (unimplemented)))

(def FRSQRTE-vector
    "0 Q 1 01110 1 s 10000 11101 10 nnnnn ddddd"
    "frsqrte V$rd.$t, V$rn.$t"
    (names (Q Q) (size s) (rn n) (rd d))
    (let t (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (= (vec rd) (match (: size Q)
        0b00 (vec-frsqrte (vec rn) 32 2)
        0b01 (vec-frsqrte (vec rn) 32 4)
        0b11 (vec-frsqrte (vec rn) 64 2)
        (unimplemented))))

(defm frsqrts (a b size type)
    (vec/ (vec- (vector-all (type 3)) (vec* a b size) size) (vector-all (type 2)) size))

(def FRSQRTS-vector
    "0 Q 0 01110 1 s 1 mmmmm 11111 1 nnnnn ddddd"
    "frsqrts V$rd.$t, V$rn.$t, V$rm.$t"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let t (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (match (: size Q)
        0b00 (= (vec rd) (vector-zero-top (frsqrts (vec rn) (vec rm) 32 f32)))
        0b01 (= (vec rd) (frsqrts (vec rn) (vec rm) 32 f32))
        0b11 (= (vec rd) (frsqrts (vec rn) (vec rm) 64 f64))
        (unimplemented)))

(def FSQRT-scalar
    "0 0 0 11110 tt 1 0000 11 10000 nnnnn ddddd"
    "fsqrt $r$rd, $r$rn"
    (names (type t) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (sqrt (vec-s rn)))
        0b01 (= (vec-d rd) (sqrt (vec-d rn)))
        (unimplemented)))

(def FSUB-scalar
    "0 0 0 11110 tt 1 mmmmm 001 1 10 nnnnn ddddd"
    "fsub $r$rd, $r$rn, $r$rm"
    (names (type t) (rm m) (rn n) (rd d))
    (let r (match type
        0b11 "H"
        0b00 "S"
        0b01 "D"
        (unimplemented)))
    (match type
        0b00 (= (vec-s rd) (- (vec-s rn) (vec-s rm)))
        0b01 (= (vec-d rd) (- (vec-d rn) (vec-d rm)))
        (unimplemented)))

(def FSUB-vector
    "0 Q 0 01110 1 s 1 mmmmm 11010 1 nnnnn ddddd"
    "fsub V$rd.$ts, V$rn.$ts, V$rm.$ts"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let ts (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (match (: size Q)
        0b00 (= (vec rd) (vector-zero-top (vec- (vec rn) (vec rm) 32)))
        0b01 (= (vec rd) (vec- (vec rn) (vec rm) 32))
        0b11 (= (vec rd) (vec- (vec rn) (vec rm) 64))
        (unimplemented)))

(def INS-general
    "0 1 0 01110000 iiiii 0 0011 1 nnnnn ddddd"
    "ins V$rd.$ts[$index], $r$rn"
    (names (imm i) (rn n) (rd d))
    (block
        (requires (!= (& imm 0b01111) 0))
        (let ts "") (let index (u32 0)) (let r "W")
        (if (== (& imm 0b00001) 0b00001)
            (block (= ts "B") (= index (>> imm 1)))
            (if (== (& imm 0b00010) 0b00010)
                (block (= ts "H") (= index (>> imm 2)))
                (if (== (& imm 0b00100) 0b00100)
                    (block (= ts "S") (= index (>> imm 3)))
                    (block (= ts "D") (= index (>> imm 4)) (= r "X"))))))
    (if (== (& imm 0b00001) 0b00001)
        (vector-insert rd index (u8 (gpr64 rn)))
        (if (== (& imm 0b00010) 0b00010)
            (vector-insert rd index (u16 (gpr64 rn)))
            (if (== (& imm 0b00100) 0b00100)
                (vector-insert rd index (bitcast (gpr32 rn) f32))
                (vector-insert rd index (bitcast (gpr64 rn) f64))))))

(def INS-vector
    "0 1 1 01110000 iiiii 0 jjjj 1 nnnnn ddddd"
    "ins V$rd.$ts[$index1], V$rn.$ts[$index2]"
    (names (imm5 i) (imm4 j) (rn n) (rd d))
    (block
        (requires (!= (& imm5 0b01111) 0))
        (let ts "") (let index1 (u32 0)) (let index2 (u32 0))
        (if (== (& imm5 0b00001) 0b00001)
            (block (= ts "B") (= index1 (>> imm5 1)) (= index2 imm4))
            (if (== (& imm5 0b00010) 0b00010)
                (block (= ts "H") (= index1 (>> imm5 2)) (= index2 (>> imm4 1)))
                (if (== (& imm5 0b00100) 0b00100)
                    (block (= ts "S") (= index1 (>> imm5 3)) (= index2 (>> imm4 2)))
                    (block (= ts "D") (= index1 (>> imm5 4)) (= index2 (>> imm4 3)))))))
    (if (== (& imm5 0b00001) 0b00001)
        (vector-insert rd index1 (vector-element (vec rn) index2 u8))
        (if (== (& imm5 0b00010) 0b00010)
            (vector-insert rd index1 (vector-element (vec rn) index2 u16))
            (if (== (& imm5 0b00100) 0b00100)
                (vector-insert rd index1 (vector-element (vec rn) index2 f32))
                (vector-insert rd index1 (vector-element (vec rn) index2 f64))))))

(defm ld1-sub (register size type offset)
    (vector-insert register i (load (+ address (+ (literal (* i size)) offset)) type)))

(def LD1-multi-no-offset-one-register
    "0 Q 0011000 1 000000 0111 ss nnnnn ttttt"
    "ld1 { V$rt.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (let T (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        0b11_0 "1D"
               "2D"))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld1-sub rt 1 u8  0))
            0b01 (qfor i 4  8 (ld1-sub rt 2 u16 0))
            0b10 (qfor i 2  4 (ld1-sub rt 4 f32 0))
                 (qfor i 1  2 (ld1-sub rt 8 f64 0)))))

(def LD1-multi-no-offset-two-registers
    "0 Q 0011000 1 000000 1010 ss nnnnn ttttt"
    "ld1 { V$rt.$T, V$rt2.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (let rt2 (% (+ rt 1) 32)
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_0 "1D"
                   "2D")))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld1-sub rt 1 u8  0))
            0b01 (qfor i 4  8 (ld1-sub rt 2 u16 0))
            0b10 (qfor i 2  4 (ld1-sub rt 4 f32 0))
                 (qfor i 1  2 (ld1-sub rt 8 f64 0)))
        (let offset (if Q 16 8)
            (match size
                0b00 (qfor i 8 16 (ld1-sub rt2 1 u8  offset))
                0b01 (qfor i 4  8 (ld1-sub rt2 2 u16 offset))
                0b10 (qfor i 2  4 (ld1-sub rt2 4 f32 offset))
                     (qfor i 1  2 (ld1-sub rt2 8 f64 offset))))))

(def LD1-multi-no-offset-three-registers
    "0 Q 0011000 1 000000 0110 ss nnnnn ttttt"
    "ld1 { V$rt.$T, V$rt2.$T, V$rt3.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_0 "1D"
                   "2D")))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (= (vec rt3) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld1-sub rt 1 u8  0))
            0b01 (qfor i 4  8 (ld1-sub rt 2 u16 0))
            0b10 (qfor i 2  4 (ld1-sub rt 4 f32 0))
                 (qfor i 1  2 (ld1-sub rt 8 f64 0)))
        (let offset (if Q 16 8)
            (match size
                0b00 (qfor i 8 16 (ld1-sub rt2 1 u8  offset))
                0b01 (qfor i 4  8 (ld1-sub rt2 2 u16 offset))
                0b10 (qfor i 2  4 (ld1-sub rt2 4 f32 offset))
                     (qfor i 1  2 (ld1-sub rt2 8 f64 offset)))
            (= offset (if Q 32 16))
            (match size
                0b00 (qfor i 8 16 (ld1-sub rt3 1 u8  offset))
                0b01 (qfor i 4  8 (ld1-sub rt3 2 u16 offset))
                0b10 (qfor i 2  4 (ld1-sub rt3 4 f32 offset))
                     (qfor i 1  2 (ld1-sub rt3 8 f64 offset))))))

(def LD1-multi-no-offset-four-registers
    "0 Q 0011000 1 000000 0010 ss nnnnn ttttt"
    "ld1 { V$rt.$T, V$rt2.$T, V$rt3.$T, V$rt4.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) rt4 (% (+ rt 3) 32))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_0 "1D"
                   "2D")))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (= (vec rt3) (vector-all (u8 0)))
        (= (vec rt4) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld1-sub rt 1 u8  0))
            0b01 (qfor i 4  8 (ld1-sub rt 2 u16 0))
            0b10 (qfor i 2  4 (ld1-sub rt 4 f32 0))
                 (qfor i 1  2 (ld1-sub rt 8 f64 0)))
        (let offset (if Q 16 8)
            (match size
                0b00 (qfor i 8 16 (ld1-sub rt2 1 u8  offset))
                0b01 (qfor i 4  8 (ld1-sub rt2 2 u16 offset))
                0b10 (qfor i 2  4 (ld1-sub rt2 4 f32 offset))
                     (qfor i 1  2 (ld1-sub rt2 8 f64 offset)))
            (= offset (if Q 32 16))
            (match size
                0b00 (qfor i 8 16 (ld1-sub rt3 1 u8  offset))
                0b01 (qfor i 4  8 (ld1-sub rt3 2 u16 offset))
                0b10 (qfor i 2  4 (ld1-sub rt3 4 f32 offset))
                     (qfor i 1  2 (ld1-sub rt3 8 f64 offset)))
            (= offset (if Q 48 24))
            (match size
                0b00 (qfor i 8 16 (ld1-sub rt4 1 u8  offset))
                0b01 (qfor i 4  8 (ld1-sub rt4 2 u16 offset))
                0b10 (qfor i 2  4 (ld1-sub rt4 4 f32 offset))
                     (qfor i 1  2 (ld1-sub rt4 8 f64 offset))))))

(def LD1-single-no-offset
    "0 Q 0011010 1 0 00000 xx0 S zz nnnnn ttttt"
    "ld1 { V$rt.$t }[$index], [X$rn]"
    (names (Q Q) (opc x) (S S) (size z) (rn n) (rt t))
    (block
        (requires (!= opc 0b11))
        (let t (if (== opc 0b00)
            "B"
            (if (& (== opc 0b01) (== (& size 1) 0))
                "H"
                (if (== opc 0b10)
                    (if (== size 0b00)
                        "S"
                        (if (& (== size 0b01) (== S 0))
                            "D"
                            (unimplemented)))
                    (unimplemented)))))
        (let index (match opc
            0b00 (u32 (: Q S size))
            0b01 (>> (u32 (: Q S size)) 1)
            0b10 (if (== (& size 1) 0)
                (u32 (: Q S))
                Q)
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (match opc
            0b00 (vector-insert rt index (load address u8))
            0b01 (vector-insert rt index (load address u16))
            0b10 (if (== size 0b00)
                (vector-insert rt index (load address f32))
                (vector-insert rt index (load address f64)))
            (unimplemented))))

(def LD1R-single-no-offset
    "0 Q 0011010 1 0 00000 110 0 zz nnnnn ttttt"
    "ld1r { V$rt.$t }, [X$rn]"
    (names (Q Q) (size z) (rn n) (rt t))
    (let t (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        0b11_0 "1D"
               "2D"))
    (let address (gpr-or-sp64 rn)
        (let sv (match size
                0b00 (vector-all (load address u8))
                0b01 (vector-all (load address u16))
                0b10 (vector-all (load address f32))
                     (vector-all (load address f64)))
            (= (vec rt) (if Q sv (vector-zero-top sv))))))

(def LD1R-single-postindex-immediate
    "0 Q 0011011 1 0 mmmmm 110 0 zz nnnnn ttttt"
    "ld1r { V$rt.$t }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size z) (rn n) (rt t))
    (block
        (requires (== rm 0b11111))
        (let t (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_0 "1D"
                   "2D"))
        (let imm (match size
            0b00 1
            0b01 2
            0b10 4
                 8)))
    (let address (gpr-or-sp64 rn)
        (let sv (match size
                0b00 (vector-all (load address u8))
                0b01 (vector-all (load address u16))
                0b10 (vector-all (load address f32))
                     (vector-all (load address f64)))
            (= (vec rt) (if Q sv (vector-zero-top sv)))
            (= (gpr-or-sp64 rn) (+ address imm)))))

(def LD1R-single-postindex-register
    "0 Q 0011011 1 0 mmmmm 110 0 zz nnnnn ttttt"
    "ld1r { V$rt.$t }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size z) (rn n) (rt t))
    (block
        (requires (!= rm 0b11111))
        (let t (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_0 "1D"
                   "2D")))
    (let address (gpr-or-sp64 rn)
        (let sv (match size
                0b00 (vector-all (load address u8))
                0b01 (vector-all (load address u16))
                0b10 (vector-all (load address f32))
                     (vector-all (load address f64)))
            (= (vec rt) (if Q sv (vector-zero-top sv)))
            (= (gpr-or-sp64 rn) (+ address (gpr64 rm))))))

(defm ld2-sub (size type) (block
    (vector-insert rt i (load (+ address (literal (* i (* size 2)))) type))
    (vector-insert rt2 i (load (+ address (literal (+ size (* i (* size 2))))) type))))

(def LD2-multi-no-offset
    "0 Q 0011000 1 000000 1000 ss nnnnn ttttt"
    "ld2 { V$rt.$T, V$rt2.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (let rt2 (% (+ rt 1) 32)
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld2-sub 1 u8))
            0b01 (qfor i 4  8 (ld2-sub 2 u16))
            0b10 (qfor i 2  4 (ld2-sub 4 f32))
                 (for (i 2)   (ld2-sub 8 f64)))))

(def LD2-multi-postindex-immediate
    "0 Q 0011001 1 0 mmmmm 1000 ss nnnnn ttttt"
    "ld2 { V$rt.$T, V$rt2.$T }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) imm (u8 (if Q 32 16)))
        (requires (== rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld2-sub 1 u8))
            0b01 (qfor i 4  8 (ld2-sub 2 u16))
            0b10 (qfor i 2  4 (ld2-sub 4 f32))
                 (for (i 2)   (ld2-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def LD2-multi-postindex-register
    "0 Q 0011001 1 0 mmmmm 1000 ss nnnnn ttttt"
    "ld2 { V$rt.$T, V$rt2.$T }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (let rt2 (% (+ rt 1) 32)
        (requires (!= rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld2-sub 1 u8))
            0b01 (qfor i 4  8 (ld2-sub 2 u16))
            0b10 (qfor i 2  4 (ld2-sub 4 f32))
                 (for (i 2)   (ld2-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address (gpr64 rm)))))

(defm ld3-sub (size type) (block
    (vector-insert rt i (load (+ address (literal (* i (* size 3)))) type))
    (vector-insert rt2 i (load (+ address (literal (+ size (* i (* size 3))))) type))
    (vector-insert rt3 i (load (+ address (literal (+ (* size 2) (* i (* size 3))))) type))))

(def LD3-multi-no-offset
    "0 Q 0011000 1 000000 0100 ss nnnnn ttttt"
    "ld3 { V$rt.$T, V$rt2.$T, V$rt3.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (= (vec rt3) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld3-sub 1 u8))
            0b01 (qfor i 4  8 (ld3-sub 2 u16))
            0b10 (qfor i 2  4 (ld3-sub 4 f32))
                 (for (i 2)   (ld3-sub 8 f64)))))

(def LD3-multi-postindex-immediate
    "0 Q 0011001 1 0 mmmmm 0100 ss nnnnn ttttt"
    "ld3 { V$rt.$T, V$rt2.$T, V$rt3.$T }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) imm (u8 (if Q 48 24)))
        (requires (== rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (= (vec rt3) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld3-sub 1 u8))
            0b01 (qfor i 4  8 (ld3-sub 2 u16))
            0b10 (qfor i 2  4 (ld3-sub 4 f32))
                 (for (i 2)   (ld3-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def LD3-multi-postindex-register
    "0 Q 0011001 1 0 mmmmm 0100 ss nnnnn ttttt"
    "ld3 { V$rt.$T, V$rt2.$T, V$rt3.$T }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32))
        (requires (!= rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (= (vec rt3) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld3-sub 1 u8))
            0b01 (qfor i 4  8 (ld3-sub 2 u16))
            0b10 (qfor i 2  4 (ld3-sub 4 f32))
                 (for (i 2)   (ld3-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address (gpr64 rm)))))

(defm ld4-sub (size type) (block
    (vector-insert rt i (load (+ address (literal (* i (* size 4)))) type))
    (vector-insert rt2 i (load (+ address (literal (+ size (* i (* size 4))))) type))
    (vector-insert rt3 i (load (+ address (literal (+ (* size 2) (* i (* size 4))))) type))
    (vector-insert rt4 i (load (+ address (literal (+ (* size 3) (* i (* size 4))))) type))))

(def LD4-multi-no-offset
    "0 Q 0011000 1 000000 0000 ss nnnnn ttttt"
    "ld4 { V$rt.$T, V$rt2.$T, V$rt3.$T, V$rt4.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) rt4 (% (+ rt 3) 32))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (= (vec rt3) (vector-all (u8 0)))
        (= (vec rt4) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld4-sub 1 u8))
            0b01 (qfor i 4  8 (ld4-sub 2 u16))
            0b10 (qfor i 2  4 (ld4-sub 4 f32))
                 (for (i 2)   (ld4-sub 8 f64)))))

(def LD4-multi-postindex-immediate
    "0 Q 0011001 1 0 mmmmm 0000 ss nnnnn ttttt"
    "ld4 { V$rt.$T, V$rt2.$T, V$rt3.$T, V$rt4.$T }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) rt4 (% (+ rt 3) 32) imm (u8 (if Q 64 32)))
        (requires (== rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (= (vec rt3) (vector-all (u8 0)))
        (= (vec rt4) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld4-sub 1 u8))
            0b01 (qfor i 4  8 (ld4-sub 2 u16))
            0b10 (qfor i 2  4 (ld4-sub 4 f32))
                 (for (i 2)   (ld4-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def LD4-multi-postindex-register
    "0 Q 0011001 1 0 mmmmm 0000 ss nnnnn ttttt"
    "ld4 { V$rt.$T, V$rt2.$T, V$rt3.$T, V$rt4.$T }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) rt4 (% (+ rt 3) 32))
        (requires (!= rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (= (vec rt) (vector-all (u8 0)))
        (= (vec rt2) (vector-all (u8 0)))
        (= (vec rt3) (vector-all (u8 0)))
        (= (vec rt4) (vector-all (u8 0)))
        (match size
            0b00 (qfor i 8 16 (ld4-sub 1 u8))
            0b01 (qfor i 4  8 (ld4-sub 2 u16))
            0b10 (qfor i 2  4 (ld4-sub 4 f32))
                 (for (i 2)   (ld4-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address (gpr64 rm)))))

(def LDAR
    "1s 001000 1 1 0 11111 1 11111 nnnnn ttttt"
    "ldar $r$rt, [X$rn]"
    (names (size s) (rn n) (rt t))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (let address (gpr-or-sp64 rn)
            (= (gpr32 rt) (load address u32)))
        (let address (gpr-or-sp64 rn)
            (= (gpr64 rt) (load address u64)))))

(def LDARB
    "00 001000 1 1 0 11111 1 11111 nnnnn ttttt"
    "ldarb W$rt, [X$rn]"
    (names (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (= (gpr64 rt) (u64 (load address u8)))))

(def LDARH
    "01  001000 1 1 0 11111 1 11111 nnnnn ttttt"
    "ldarh W$rt, [X$rn]"
    (names (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (= (gpr64 rt) (u64 (load address u16)))))

(def LDAXB
    "1s 001000 0 1 0 11111 1 11111 nnnnn ttttt"
    "ldaxb W$rt, [X$rn]"
    (names (size s) (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (if (== size 0)
            (= (gpr32 rt) (load-exclusive address u32))
            (= (gpr64 rt) (load-exclusive address u64)))))

(def LDAXRB
    "00 001000 0 1 0 11111 1 11111 nnnnn ttttt"
    "ldaxrb W$rt, [X$rn]"
    (names (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (= (gpr64 rt) (u64 (load-exclusive address u8)))))

(def LDAXRH
    "01 001000 0 1 0 11111 1 11111 nnnnn ttttt"
    "ldaxrh W$rt, [X$rn]"
    (names (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (= (gpr64 rt) (u64 (load-exclusive address u16)))))

(def LDP-immediate-postindex
    "s0 101 0 001 1 iiiiiii ppppp nnnnn ttttt"
    "ldp $r$rt1, $r$rt2, [X$rn], #$simm"
    (names (size s) (imm i) (rt2 p) (rn n) (rt1 t))
    (block
        (requires (!= rt1 rt2))
        (requires (!= rt1 rn))
        (requires (!= rt2 rn))
        (let r (if (== size 0) "W" "X"))
        (let simm (<< (signext imm i64) (if (== size 0) 2 3))))
    (let address (gpr-or-sp64 rn)
        (if (== size 0)
            (block
                (= (gpr32 rt1) (load address u32))
                (= (gpr32 rt2) (load (+ address 4) u32)))
            (block
                (= (gpr64 rt1) (load address u64))
                (= (gpr64 rt2) (load (+ address 8) u64))))
        (= (gpr-or-sp64 rn) (+ address simm))))

(def LDP-immediate-signed-offset
    "s0 101 0 010 1 iiiiiii ppppp nnnnn ttttt"
    "ldp $r$rt1, $r$rt2, [X$rn, #$simm]"
    (names (size s) (imm i) (rt2 p) (rn n) (rt1 t))
    (block
        (requires (!= rt1 rt2))
        (let r (if (== size 0) "W" "X"))
        (let simm (<< (signext imm i64) (if (== size 0) 2 3))))
    (let address (+ (gpr-or-sp64 rn) simm)
        (if (== size 0)
            (block
                (= (gpr32 rt1) (load address u32))
                (= (gpr32 rt2) (load (+ address 4) u32)))
            (block
                (= (gpr64 rt1) (load address u64))
                (= (gpr64 rt2) (load (+ address 8) u64))))))

(def LDP-simd-postindex
    "oo 101 1 001 1 iiiiiii ppppp nnnnn ttttt"
    "ldp $r$rt1, $r$rt2, [X$rn], #$simm"
    (names (opc o) (imm i) (rt2 p) (rn n) (rt1 t))
    (block
        (requires (!= rt1 rt2))
        (let r (match opc 0b00 "S" 0b01 "D" "Q"))
        (let simm (<< (signext imm i64) (match opc 0b00 2 0b01 3 4))))
    (let address (gpr-or-sp64 rn)
        (match opc
            0b00 (block
                (= (vec-s rt1) (load address f32))
                (= (vec-s rt2) (load (+ address 4) f32)))
            0b01 (block
                (= (vec-d rt1) (load address f64))
                (= (vec-d rt2) (load (+ address 8) f64)))
            (block
                (= (vec rt1) (load address vec))
                (= (vec rt2) (load (+ address 16) vec))))
        (= (gpr-or-sp64 rn) (+ address simm))))

(def LDP-simd-preindex
    "oo 101 1 011 1 iiiiiii ppppp nnnnn ttttt"
    "ldp $r$rt1, $r$rt2, [X$rn, #$simm]!"
    (names (opc o) (imm i) (rt2 p) (rn n) (rt1 t))
    (block
        (requires (!= rt1 rt2))
        (let r (match opc 0b00 "S" 0b01 "D" "Q"))
        (let simm (<< (signext imm i64) (match opc 0b00 2 0b01 3 4))))
    (let address (+ (gpr-or-sp64 rn) simm)
        (= (gpr-or-sp64 rn) address)
        (match opc
            0b00 (block
                (= (vec-s rt1) (load address f32))
                (= (vec-s rt2) (load (+ address 4) f32)))
            0b01 (block
                (= (vec-d rt1) (load address f64))
                (= (vec-d rt2) (load (+ address 8) f64)))
            (block
                (= (vec rt1) (load address vec))
                (= (vec rt2) (load (+ address 16) vec))))))

(def LDP-simd-signed-offset
    "oo 101 1 010 1 iiiiiii ppppp nnnnn ttttt"
    "ldp $r$rt1, $r$rt2, [X$rn, #$simm]"
    (names (opc o) (imm i) (rt2 p) (rn n) (rt1 t))
    (block
        (requires (!= rt1 rt2))
        (let r (match opc 0b00 "S" 0b01 "D" "Q"))
        (let simm (<< (signext imm i64) (match opc 0b00 2 0b01 3 4))))
    (let address (+ (gpr-or-sp64 rn) simm)
        (match opc
            0b00 (block
                (= (vec-s rt1) (load address f32))
                (= (vec-s rt2) (load (+ address 4) f32)))
            0b01 (block
                (= (vec-d rt1) (load address f64))
                (= (vec-d rt2) (load (+ address 8) f64)))
            (block
                (= (vec rt1) (load address vec))
                (= (vec rt2) (load (+ address 16) vec))))))

(def LDPSW-immediate-signed-offset
    "01 101 0 010 1 iiiiiii ppppp nnnnn ttttt"
    "ldpsw X$rt1, X$rt2, [X$rn, #$simm]"
    (names (imm i) (rt2 p) (rn n) (rt1 t))
    (block
        (requires (!= rt1 rt2))
        (requires (!= rt1 rn))
        (requires (!= rt2 rn))
        (let simm (<< (signext imm i64) 2)))
    (let address (+ (gpr-or-sp64 rn) simm)
        (= (gpr64 rt1) (u64 (signext (load address u32) i64)))
        (= (gpr64 rt2) (u64 (signext (load (+ address 4) u32) i64)))))

(def LDR-immediate-preindex
    "1s 111 0 00 01 0 iiiiiiiii 11 nnnnn ddddd"
    "ldr $r$rd, [X$rn, #$imm]!"
    (names (size s) (rawimm i) (rn n) (rd d))
    (block
        (requires (!= rd rn))
        (let r (if (== size 0) "W" "X"))
        (let imm (signext rawimm i64)))
    (let address (+ (gpr-or-sp64 rn) imm)
        (if (== size 0)
            (= (gpr32 rd) (load address u32))
            (= (gpr64 rd) (load address u64)))
        (= (gpr-or-sp64 rn) address)))

(def LDR-immediate-postindex
    "1s 111 0 00 01 0 iiiiiiiii 01 nnnnn ddddd"
    "ldr $r$rd, [X$rn], #$imm"
    (names (size s) (rawimm i) (rn n) (rd d))
    (block
        (requires (!= rd rn))
        (let r (if (== size 0) "W" "X"))
        (let imm (signext rawimm i64)))
    (block
        (if (== size 0)
            (= (gpr32 rd) (load (gpr-or-sp64 rn) u32))
            (= (gpr64 rd) (load (gpr-or-sp64 rn) u64)))
        (= (gpr-or-sp64 rn) (+ (gpr-or-sp64 rn) imm))))

(def LDR-immediate-unsigned-offset
    "1s 111 0 01 01 iiiiiiiiiiii nnnnn ddddd"
    "ldr $r$rd, [X$rn, #$imm]"
    (names (size s) (rawimm i) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (<< rawimm (if (== size 0) 2 3))))
    (if (== size 0)
        (= (gpr32 rd) (load (+ (gpr-or-sp64 rn) imm) u32))
        (= (gpr64 rd) (load (+ (gpr-or-sp64 rn) imm) u64))))

(def LDR-literal
    "0s 011 0 00 iiiiiiiiiiiiiiiiiii ttttt"
    "ldr $r$rt, #$addr"
    (names (size s) (rawimm i) (rt t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let offset (signext (cast (<< rawimm 2) u21) i64))
        (let addr (+ (pc) offset)))
    (if (== size 0)
        (= (gpr32 rt) (load addr u32))
        (= (gpr64 rt) (load addr u64))))

(def LDR-simd-immediate-postindex
    "ss 111 1 00 o1 0 iiiiiiiii 01 nnnnn ttttt"
    "ldr $r$rt, [X$rn], #$simm"
    (names (size s) (opc o) (imm i) (rn n) (rt t))
    (block
        (let simm (signext imm i64))
        (let r (match (: size opc)
            0b00_0 "B"
            0b01_0 "H"
            0b10_0 "S"
            0b11_0 "D"
            0b00_1 "Q"
            (unimplemented))))
    (let address (gpr-or-sp64 rn)
        (match (: size opc)
            0b00_0 (= (vec-b rt) (load address u8))
            0b01_0 (= (vec-h rt) (load address u16))
            0b10_0 (= (vec-s rt) (load address f32))
            0b11_0 (= (vec-d rt) (load address f64))
            0b00_1 (= (vec rt)   (load address vec))
            (unimplemented))
        (= (gpr-or-sp64 rn) (+ address simm))))

(def LDR-simd-immediate-preindex
    "ss 111 1 00 o1 0 iiiiiiiii 11 nnnnn ttttt"
    "ldr $r$rt, [X$rn, #$simm]!"
    (names (size s) (opc o) (imm i) (rn n) (rt t))
    (block
        (let simm (signext imm i64))
        (let r (match (: size opc)
            0b00_0 "B"
            0b01_0 "H"
            0b10_0 "S"
            0b11_0 "D"
            0b00_1 "Q"
            (unimplemented))))
    (let address (+ (gpr-or-sp64 rn) simm)
        (match (: size opc)
            0b00_0 (= (vec-b rt) (load address u8))
            0b01_0 (= (vec-h rt) (load address u16))
            0b10_0 (= (vec-s rt) (load address f32))
            0b11_0 (= (vec-d rt) (load address f64))
            0b00_1 (= (vec rt)   (load address vec))
            (unimplemented))
        (= (gpr-or-sp64 rn) address)))

(def LDR-simd-immediate-unsigned-offset
    "ss 111 1 01 o1 iiiiiiiiiiii nnnnn ttttt"
    "ldr $r$rt, [X$rn, #$imm]"
    (names (size s) (ropc o) (rawimm i) (rn n) (rt t))
    (block
        (let opc (: ropc (u1 1)))
        (let m (: size opc))
        (let r (match m
            0b0001 "B"
            0b0101 "H"
            0b1001 "S"
            0b1101 "D"
            "Q"))
        (let imm (<< (u32 rawimm) (match m
            0b0001 0
            0b0101 1
            0b1001 2
            0b1101 3
            4))))
    (match m
        0b0001 (= (vec-b rt) (load (+ (gpr-or-sp64 rn) imm) u8))
        0b0101 (= (vec-h rt) (load (+ (gpr-or-sp64 rn) imm) u16))
        0b1001 (= (vec-s rt) (load (+ (gpr-or-sp64 rn) imm) f32))
        0b1101 (= (vec-d rt) (load (+ (gpr-or-sp64 rn) imm) f64))
               (= (vec   rt) (load (+ (gpr-or-sp64 rn) imm) vec))))

(def LDR-simd-literal
    "ss 011 1 00 iiiiiiiiiiiiiiiiiii ttttt"
    "ldr $r$rt, #$addr"
    (names (size s) (imm i) (rt t))
    (block
        (let r (match size
            0b00 "S"
            0b01 "D"
            0b10 "Q"
            (unimplemented)))
        (let addr (+ (pc) (signext (: imm (cast 0b00 u2)) i64))))
    (match size
        0b00 (= (vec-s rt) (load addr f32))
        0b01 (= (vec-d rt) (load addr f64))
        0b10 (= (vec rt) (load addr vec))
        (unimplemented)))

(def LDR-simd-register
    "ff 111 1 00 x1 1 mmmmm ooo s 10 nnnnn ttttt"
    "ldr $r1$rt, [X$rn, $r2$rm, $extend $amount]"
    (names (size f) (opc x) (rm m) (option o) (scale s) (rn n) (rt t))
    (block
        (let r1 (if (& (== size 0) (== opc 1)) "Q" (match size
            0b00 "B"
            0b01 "H"
            0b10 "S"
            0b11 "D"
            (unimplemented))))
        (let r2 (if (& option 1) "X" "W"))
        (let extend (match option
            0b010 "UXTW"
            0b011 "LSL"
            0b110 "SXTW"
            0b111 "SXTX"
            (unimplemented)))
        (let amount (* scale (if (& (== size 0) (== opc 1)) 4 (match size
            0b00 1
            0b01 1
            0b10 2
            0b11 3
            (unimplemented))))))
    (let offset (<< (match option
            0b010 (u64 (gpr32 rm))
            0b011 (gpr64 rm)
            0b110 (u64 (signext (gpr32 rm) i64))
            0b111 (gpr64 rm)
            (unimplemented)) amount)
        (let address (+ (gpr-or-sp64 rn) offset)
            (match (: size opc)
                0b00_0 (= (vec-b rt) (load address u8))
                0b10_0 (= (vec-s rt) (load address f32))
                0b11_0 (= (vec-d rt) (load address f64))
                0b00_1 (= (vec rt) (load address vec))
                (unimplemented)))))

(def LDR-register
    "1f 111 0 00 01 1 mmmmm ooo s 10 nnnnn ttttt"
    "ldr $r1$rt, [X$rn, $r2$rm, $extend $amount]"
    (names (size f) (rm m) (option o) (scale s) (rn n) (rt t))
    (block
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (if (& option 1) "X" "W"))
        (let amount (if (== scale 0) 0 (if (== size 0) 2 3)))
        (let extend (match option
            0b010 "UXTW"
            0b110 "SXTW"
            0b111 "SXTX"
            0b011 "LSL"
            (unimplemented))))
    (let offset (<< (if (== option 0b110)
            (u64 (signext (gpr32 rm) i64))
            (if (& option 1)
                (gpr64 rm)
                (u64 (gpr32 rm)))) amount)
        (if (== size 0)
            (= (gpr32 rt) (load (+ (gpr-or-sp64 rn) offset) u32))
            (= (gpr64 rt) (load (+ (gpr-or-sp64 rn) offset) u64)))))

(def LDRB-immediate-postindex
    "00 111 0 00 01 0 iiiiiiiii 01 nnnnn ttttt"
    "ldrb W$rt, [X$rn], #$imm"
    (names (rawimm i) (rn n) (rt t))
    (block
        (requires (!= rt rn))
        (let imm (signext rawimm i64)))
    (block
        (= (gpr32 rt) (u32 (load (gpr-or-sp64 rn) u8)))
        (= (gpr-or-sp64 rn) (+ (gpr-or-sp64 rn) imm))))

(def LDRB-immediate-preindex
    "00 111 0 00 01 0 iiiiiiiii 11 nnnnn ttttt"
    "ldrb W$rt, [X$rn, #$imm]!"
    (names (rawimm i) (rn n) (rt t))
    (block
        (requires (!= rt rn))
        (let imm (signext rawimm i64)))
    (let address (+ (gpr-or-sp64 rn) imm)
        (= (gpr32 rt) (u32 (load address u8)))
        (= (gpr-or-sp64 rn) address)))

(def LDRB-immediate-unsigned-offset
    "00 111 0 01 01 iiiiiiiiiiii nnnnn ttttt"
    "ldrb W$rt, [X$rn, #$imm]"
    (names (imm i) (rt t) (rn n))
    (block)
    (= (gpr64 rt) (u64 (load (+ (gpr-or-sp64 rn) imm) u8))))

(def LDRB-register
    "00 111 0 00 01 1 mmmmm ooo s 10 nnnnn ttttt"
    "ldrb W$rt, [X$rn, $r$rm, $str $amount]"
    (names (rm m) (option o) (amount s) (rn n) (rt t))
    (let r (if (& option 1) "X" "W")
        (let str (match option
            0b010 "UXTW"
            0b011 "LSL"
            0b110 "SXTW"
            0b111 "SXTX"
            (unimplemented))))
    (let offset (<< (if (== option 0b110)
            (u64 (signext (gpr32 rm) i64))
            (if (& option 1)
                (gpr64 rm)
                (u64 (gpr32 rm)))) amount)
        (= (gpr32 rt) (load (+ (gpr-or-sp64 rn) offset) u8))))

(def LDRH-immediate-postindex
    "01 111 0 00 01 0 iiiiiiiii 01 nnnnn ttttt"
    "ldrh W$rt, [X$rn], #$imm"
    (names (rawimm i) (rn n) (rt t))
    (block
        (requires (!= rt rn))
        (let imm (signext rawimm i64)))
    (let address (gpr-or-sp64 rn)
        (= (gpr64 rt) (u64 (load address u16)))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def LDRH-immediate-preindex
    "01 111 0 00 01 0 iiiiiiiii 11 nnnnn ttttt"
    "ldrh W$rt, [X$rn, #$imm]!"
    (names (rawimm i) (rn n) (rt t))
    (block
        (requires (!= rt rn))
        (let imm (signext rawimm i64)))
    (let address (+ (gpr-or-sp64 rn) imm)
        (= (gpr64 rt) (u64 (load address u16)))
        (= (gpr-or-sp64 rn) address)))

(def LDRH-immediate-unsigned-offset
    "01 111 0 01 01 iiiiiiiiiiii nnnnn ttttt"
    "ldrh W$rt, [X$rn, #$imm]"
    (names (rawimm i) (rt t) (rn n))
    (let imm (<< rawimm 1))
    (= (gpr64 rt) (u64 (load (+ (gpr-or-sp64 rn) imm) u16))))

(def LDRH-register
    "01 111 0 00 01 1 mmmmm ooo s 10 nnnnn ttttt"
    "ldrh W$rt, [X$rn, $r$rm, $str $amount]"
    (names (rm m) (option o) (amount s) (rn n) (rt t))
    (let r (if (& option 1) "X" "W")
        (let str (match option
            0b010 "UXTW"
            0b011 "LSL"
            0b110 "SXTW"
            0b111 "SXTX"
            (unimplemented))))
    (let offset (<< (if (== option 0b110)
            (u64 (signext (gpr32 rm) i64))
            (if (& option 1)
                (gpr64 rm)
                (u64 (gpr32 rm)))) amount)
        (= (gpr32 rt) (load (+ (gpr-or-sp64 rn) offset) u16))))

(def LDRSB-immediate-postindex
    "00 111 0 00 1o 0 iiiiiiiii 01 nnnnn ttttt"
    "ldrsb $r$rt, [X$rn], #$imm"
    (names (rawimm i) (opc o) (rn n) (rt t))
    (block
        (requires (!= rt rn))
        (let imm (signext rawimm i64))
        (let r (if (== opc 1) "W" "X")))
    (let address (gpr-or-sp64 rn)
        (if (== opc 1)
            (= (gpr32 rt) (u32 (signext (load address u8) i32)))
            (= (gpr64 rt) (u64 (signext (load address u8) i64))))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def LDRSB-immediate-preindex
    "00 111 0 00 1o 0 iiiiiiiii 11 nnnnn ttttt"
    "ldrsb $r$rt, [X$rn, #$imm]!"
    (names (rawimm i) (opc o) (rn n) (rt t))
    (block
        (requires (!= rt rn))
        (let imm (signext rawimm i64))
        (let r (if (== opc 1) "W" "X")))
    (let address (+ (gpr-or-sp64 rn) imm)
        (if (== opc 1)
            (= (gpr32 rt) (u32 (signext (load address u8) i32)))
            (= (gpr64 rt) (u64 (signext (load address u8) i64))))
        (= (gpr-or-sp64 rn) address)))

(def LDRSB-immediate-unsigned-offset
    "00 111 0 01 1s iiiiiiiiiiii nnnnn ttttt"
    "ldrsb $r$rt, [X$rn, #$imm]"
    (names (opc s) (imm i) (rt t) (rn n))
    (let r (if (== opc 1) "W" "X"))
    (if (== opc 1)
        (= (gpr32 rt) (u32 (signext (load (+ (gpr-or-sp64 rn) imm) u8) i32)))
        (= (gpr64 rt) (u64 (signext (load (+ (gpr-or-sp64 rn) imm) u8) i64)))))

(def LDRSB-register
    "00 111 0 00 1x 1 mmmmm ooo s 10 nnnnn ttttt"
    "ldrsb $r$rt, [X$rn, $r$rm, $str $amount]"
    (names (rm m) (opc x) (option o) (amount s) (rn n) (rt t))
    (let r (if (== opc 0) "X" "W")
        (let str (match option
            0b010 "UXTW"
            0b011 "LSL"
            0b110 "SXTW"
            0b111 "SXTX"
            (unimplemented))))
    (let offset (<< (if (== option 0b110)
            (u64 (signext (gpr32 rm) i64))
            (if (& option 1)
                (gpr64 rm)
                (u64 (gpr32 rm)))) amount)
        (if (== opc 1)
            (= (gpr32 rt) (u32 (signext (load (+ (gpr-or-sp64 rn) offset) u8) i32)))
            (= (gpr64 rt) (u64 (signext (load (+ (gpr-or-sp64 rn) offset) u8) i64))))))

(def LDRSH-immediate-postindex
    "01 111 0 00 1o 0 iiiiiiiii 01 nnnnn ttttt"
    "ldrsh $r$rt, [X$rn], #$imm"
    (names (rawimm i) (opc o) (rn n) (rt t))
    (block
        (requires (!= rt rn))
        (let imm (signext rawimm i64))
        (let r (if (== opc 1) "W" "X")))
    (let address (gpr-or-sp64 rn)
        (if (== opc 1)
            (= (gpr32 rt) (u32 (signext (load address u16) i32)))
            (= (gpr64 rt) (u64 (signext (load address u16) i64))))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def LDRSH-immediate-preindex
    "01 111 0 00 1o 0 iiiiiiiii 11 nnnnn ttttt"
    "ldrsh $r$rt, [X$rn, #$imm]!"
    (names (rawimm i) (opc o) (rn n) (rt t))
    (block
        (requires (!= rt rn))
        (let imm (signext rawimm i64))
        (let r (if (== opc 1) "W" "X")))
    (let address (+ (gpr-or-sp64 rn) imm)
        (if (== opc 1)
            (= (gpr32 rt) (u32 (signext (load address u16) i32)))
            (= (gpr64 rt) (u64 (signext (load address u16) i64))))
        (= (gpr-or-sp64 rn) address)))

(def LDRSH-immediate-unsigned-offset
    "01 111 0 01 1o iiiiiiiiiiii nnnnn ttttt"
    "ldrsh $r$rt, [X$rn, #$imm]"
    (names (opc o) (rawimm i) (rt t) (rn n))
    (block
        (let r (if (== opc 1) "W" "X"))
        (let imm (<< rawimm 1)))
    (if (== opc 1)
        (= (gpr32 rt) (u32 (signext (load (+ (gpr-or-sp64 rn) imm) u16) i32)))
        (= (gpr64 rt) (u64 (signext (load (+ (gpr-or-sp64 rn) imm) u16) i64)))))

(def LDRSH-register
    "01 111 0 00 1x 1 mmmmm ooo s 10 nnnnn ttttt"
    "ldrsh $r$rt, [X$rn, $r$rm, $str $amount]"
    (names (rm m) (opc x) (option o) (amount s) (rn n) (rt t))
    (let r (if (== opc 0) "X" "W")
        (let str (match option
            0b010 "UXTW"
            0b011 "LSL"
            0b110 "SXTW"
            0b111 "SXTX"
            (unimplemented))))
    (let offset (<< (if (== option 0b110)
            (u64 (signext (gpr32 rm) i64))
            (if (& option 1)
                (gpr64 rm)
                (u64 (gpr32 rm)))) amount)
        (if (== opc 1)
            (= (gpr32 rt) (u32 (signext (load (+ (gpr-or-sp64 rn) offset) u16) i32)))
            (= (gpr64 rt) (u64 (signext (load (+ (gpr-or-sp64 rn) offset) u16) i64))))))

(def LDRSW-immediate-postindex
    "10 111 0 00 10 0 iiiiiiiii 01 nnnnn ttttt"
    "ldrsw X$rt, [X$rn], #$imm"
    (names (rawimm i) (rn n) (rt t))
    (block
        (requires (!= rt rn))
        (let imm (signext rawimm i64)))
    (let address (gpr-or-sp64 rn)
        (= (gpr64 rt) (u64 (signext (load address u32) i64)))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def LDRSW-immediate-preindex
    "10 111 0 00 10 0 iiiiiiiii 11 nnnnn ttttt"
    "ldrsw X$rt, [X$rn, #$imm]!"
    (names (rawimm i) (rn n) (rt t))
    (block
        (requires (!= rt rn))
        (let imm (signext rawimm i64)))
    (let address (+ (gpr-or-sp64 rn) imm)
        (= (gpr64 rt) (u64 (signext (load address u32) i64)))
        (= (gpr-or-sp64 rn) address)))

(def LDRSW-immediate-unsigned-offset
    "10 111 0 01 10 iiiiiiiiiiii nnnnn ttttt"
    "ldrsw X$rt, [X$rn, #$imm]"
    (names (rawimm i) (rt t) (rn n))
    (let imm (<< rawimm 2))
    (= (gpr64 rt) (u64 (signext (load (+ (gpr-or-sp64 rn) imm) u32) i64))))

(def LDRSW-literal
    "10 011 0 00 iiiiiiiiiiiiiiiiiii ttttt"
    "ldrsw X$rt, #$addr"
    (names (imm i) (rt t))
    (let addr (+ (pc) (signext (: imm (cast 0b00 u2)) i64)))
    (= (gpr64 rt) (u64 (signext (load addr u32) i64))))

(def LDRSW-register
    "10 111 0 00 10 1 mmmmm ooo s 10 nnnnn ttttt"
    "ldrsw X$rt, [X$rn, $r$rm, $extend $amount]"
    (names (rm m) (option o) (scale s) (rn n) (rt t))
    (block
        (let r (if (& option 1) "X" "W"))
        (let amount (if (== scale 0) 0 2))
        (let extend (match option
            0b010 "UXTW"
            0b110 "SXTW"
            0b111 "SXTX"
            (unimplemented))))
    (let offset (<< (if (== option 0b110)
            (u64 (signext (gpr32 rm) i64))
            (if (& option 1)
                (gpr64 rm)
                (u64 (gpr32 rm)))) amount)
        (= (gpr64 rt) (u64 (signext (load (+ (gpr-or-sp64 rn) offset) u32) i64)))))

(def LDUR
    "1s 111 0 00 01 0 iiiiiiiii 00 nnnnn ttttt"
    "ldur $r$rd, [X$rn, #$imm]"
    (names (size s) (rawimm i) (rn n) (rd t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (signext rawimm i64)))
    (if (== size 0)
        (= (gpr32 rd) (load (+ (gpr-or-sp64 rn) imm) u32))
        (= (gpr64 rd) (load (+ (gpr-or-sp64 rn) imm) u64))))

(def LDURB
    "00 111 0 00 01 0 iiiiiiiii 00 nnnnn ttttt"
    "ldurb W$rd, [X$rn, #$imm]"
    (names (rawimm i) (rn n) (rd t))
    (let imm (signext rawimm i64))
    (= (gpr64 rd) (u64 (load (+ (gpr-or-sp64 rn) imm) u8))))

(def LDURH
    "01 111 0 00 01 0 iiiiiiiii 00 nnnnn ttttt"
    "ldurh W$rd, [X$rn, #$imm]"
    (names (rawimm i) (rn n) (rd t))
    (let imm (signext rawimm i64))
    (= (gpr64 rd) (u64 (load (+ (gpr-or-sp64 rn) imm) u16))))

(def LDURSB
    "00 111 0 00 1x 0 iiiiiiiii 00 nnnnn ttttt"
    "ldursb $r$rd, [X$rn, #$imm]"
    (names (opc x) (rawimm i) (rn n) (rd t))
    (block
        (let r (if (== opc 1) "W" "X"))
        (let imm (signext rawimm i64)))
    (if (== opc 1)
        (= (gpr32 rd) (u32 (signext (load (+ (gpr-or-sp64 rn) imm) u8) i32)))
        (= (gpr64 rd) (u64 (signext (load (+ (gpr-or-sp64 rn) imm) u8) i64)))))

(def LDURSH
    "01 111 0 00 1x 0 iiiiiiiii 00 nnnnn ttttt"
    "ldursh $r$rd, [X$rn, #$imm]"
    (names (opc x) (rawimm i) (rn n) (rd t))
    (block
        (let r (if (== opc 1) "W" "X"))
        (let imm (signext rawimm i64)))
    (if (== opc 1)
        (= (gpr32 rd) (u32 (signext (load (+ (gpr-or-sp64 rn) imm) u16) i32)))
        (= (gpr64 rd) (u64 (signext (load (+ (gpr-or-sp64 rn) imm) u16) i64)))))

(def LDURSW
    "10 111 0 00 10 0 iiiiiiiii 00 nnnnn ttttt"
    "ldursw X$rt, [X$rn, #$imm]"
    (names (rawimm i) (rn n) (rt t))
    (let imm (signext rawimm i64))
    (= (gpr64 rt) (u64 (signext (load (+ (gpr-or-sp64 rn) imm) u32) i64))))

(def LDUR-simd
    "ss 111 1 00 x1 0 iiiiiiiii 00 nnnnn ttttt"
    "ldur $r$rt, [X$rn, #$imm]"
    (names (size s) (opc x) (rawimm i) (rn n) (rt t))
    (block
        (let r (match (: size opc)
            0b00_0 "B"
            0b01_0 "H"
            0b10_0 "S"
            0b11_0 "D"
            0b00_1 "Q"
            (unimplemented)))
        (let imm (signext rawimm i64)))
    (let address (+ (gpr-or-sp64 rn) imm)
        (match (: size opc)
            0b00_0 (= (vec-b rt) (load address u8))
            0b10_0 (= (vec-s rt) (load address f32))
            0b11_0 (= (vec-d rt) (load address f64))
            0b00_1 (= (vec   rt) (load address vec)))))

(def LDXR
    "1s 001000 0 1 0 11111 0 11111 nnnnn ttttt"
    "ldxr $r$rt, [X$rn]"
    (names (size s) (rn n) (rt t))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rt) (load-exclusive (gpr-or-sp64 rn) u32))
        (= (gpr64 rt) (load-exclusive (gpr-or-sp64 rn) u64))))

(def LDXRB
    "00 001000 0 1 0 11111 0 11111 nnnnn ttttt"
    "ldxrb W$rt, [X$rn]"
    (names (rn n) (rt t))
    (block)
    (= (gpr64 rt) (cast (load-exclusive (gpr-or-sp64 rn) u8) u64)))

(def LDXRH
    "01 001000 0 1 0 11111 0 11111 nnnnn ttttt"
    "ldxrh W$rt, [X$rn]"
    (names (rn n) (rt t))
    (block)
    (= (gpr64 rt) (cast (load-exclusive (gpr-or-sp64 rn) u16) u64)))

(def LDXP
    "1 s 001000 0 1 1 11111 0 uuuuu nnnnn ttttt"
    "ldxp $r$rt, $r$rt2, [X$rn]"
    (names (size s) (rt2 u) (rn n) (rt t))
    (let r (if (== size 0) "W" "X"))
    (let address (gpr-or-sp64 rn)
        (if (== size 0)
            (block
                (= (gpr32 rt) (load-exclusive address u32))
                (= (gpr32 rt2) (load-exclusive (+ address 4) u32)))
            (block
                (= (gpr64 rt) (load-exclusive address u64))
                (= (gpr64 rt2) (load-exclusive (+ address 8) u64))))))

(def LSL-register
    "s 0 0 11010110 mmmmm 0010 00 nnnnn ddddd"
    "lsl $r$rd, $r$rn, $r$rm"
    (names (size s) (rm m) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (<< (gpr32 rn) (% (gpr32 rm) 32)))
        (= (gpr64 rd) (<< (gpr64 rn) (% (gpr64 rm) 64)))))

(def LSRV
    "s 0 0 11010110 mmmmm 0010 01 nnnnn ddddd"
    "lsrv $r$rd, $r$rn, $r$rm"
    (names (size s) (rm m) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (>> (gpr32 rn) (% (gpr32 rm) 32)))
        (= (gpr64 rd) (>> (gpr64 rn) (% (gpr64 rm) 64)))))

(def MADD
    "s 00 11011 000 mmmmm 0 aaaaa nnnnn ddddd"
    "madd $r$rd, $r$rn, $r$rm, $r$ra"
    (names (size s) (rm m) (ra a) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (+ (* (gpr32 rn) (gpr32 rm)) (gpr32 ra)))
        (= (gpr64 rd) (+ (* (gpr64 rn) (gpr64 rm)) (gpr64 ra)))))

(def MOVI-scalar-64bit
    "0 0 1 0111100000 a b c 1110 0 1 d e f g h ttttt"
    "movi D$rd, #$imm"
    (names (a a) (b b) (c c) (d d) (e e) (f f) (g g) (h h) (rd t))
    (mlet (
            imm8a (u8 (if a 0xFF 0)) imm8b (u8 (if b 0xFF 0))
            imm8c (u8 (if c 0xFF 0)) imm8d (u8 (if d 0xFF 0))
            imm8e (u8 (if e 0xFF 0)) imm8f (u8 (if f 0xFF 0))
            imm8g (u8 (if g 0xFF 0)) imm8h (u8 (if h 0xFF 0)))
        (let imm (: imm8a imm8b imm8c imm8d imm8e imm8f imm8g imm8h)))
    (= (vec-d rd) (bitcast imm f64)))

(def MOVI-vector-8bit
    "0 Q 0 0111100000 a b c 1110 0 1 d e f g h rrrrr"
    "movi V$rd.$t, #$imm"
    (names (Q Q) (a a) (b b) (c c) (d d) (e e) (f f) (g g) (h h) (rd r))
    (block
        (let t (if Q "16B" "8B"))
        (let imm (: a b c d e f g h)))
    (let avec (vector-all (u8 imm))
        (= (vec rd) (if Q avec (vector-zero-top avec)))))

(def MOVI-vector-16bit
    "0 Q 0 0111100000 a b c 10m0 0 1 d e f g h rrrrr"
    "movi V$rd.$t, #$imm"
    (names (Q Q) (cmode m) (a a) (b b) (c c) (d d) (e e) (f f) (g g) (h h) (rd r))
    (block
        (let t (if Q "8H" "4H"))
        (let imm (: a b c d e f g h)))
    (let avec (vector-all (if cmode (u16 (<< (u16 imm) 8)) (u16 imm)))
        (= (vec rd) (if Q avec (vector-zero-top avec)))))

(def MOVI-vector-32bit
    "0 Q 0 0111100000 a b c 0mm0 0 1 d e f g h rrrrr"
    "movi V$rd.$t, #$imm, LSL #$amount"
    (names (Q Q) (cmode m) (a a) (b b) (c c) (d d) (e e) (f f) (g g) (h h) (rd r))
    (block
        (let t (if Q "4S" "2S"))
        (let amount (match cmode
            0b00 0
            0b01 8
            0b10 16
            0b11 24
            (unimplemented)))
        (let imm (: a b c d e f g h)))
    (let avec (vector-all (bitcast (<< (u32 imm) amount) f32))
        (= (vec rd) (if Q avec (vector-zero-top avec)))))

(def MOVI-Vx.2D
    "0 1 1 0111100000 a b c 1110 0 1 d e f g h rrrrr"
    "movi V$rd, #$imm"
    (names (a a) (b b) (c c) (d d) (e e) (f f) (g g) (h h) (rd r))
    (let imm (:
        (replicate a 8) (replicate b 8)
        (replicate c 8) (replicate d 8)
        (replicate e 8) (replicate f 8)
        (replicate g 8) (replicate h 8)))
    (= (vec rd) (vector-all imm)))

(def MOVK
    "s 11 100101 hh iiiiiiiiiiiiiiii ddddd"
    "movk $r$rd, #$imm, LSL #$shift"
    (names (size s) (imm i) (rd d) (hw h))
    (block
        (when (== size 0)
            (requires (< hw 2)))
        (let r (if (== size 0) "W" "X"))
        (let shift (<< (u32 hw) 4)))
    (if (== size 0)
        (= (gpr32 rd) (| (& (gpr32 rd) (^ (u32 -1) (<< (u32 0xFFFF) shift))) (<< (u32 imm) shift)))
        (= (gpr64 rd) (| (& (gpr64 rd) (^ (u64 -1) (<< (u64 0xFFFF) shift))) (<< (u64 imm) shift)))))

(def MOVN
    "s 00 100101 hh iiiiiiiiiiiiiiii ddddd"
    "movn $r$rd, #$imm, LSL #$shift"
    (names (size s) (imm i) (rd d) (hw h))
    (block
        (when (== size 0)
            (requires (< hw 2)))
        (let r (if (== size 0) "W" "X"))
        (let shift (<< (u32 hw) 4)))
    (if (== size 0)
        (= (gpr32 rd) (~ (<< (u32 imm) shift)))
        (= (gpr64 rd) (~ (<< (u64 imm) shift)))))

(def MOVZ
    "s 10 100101 hh iiiiiiiiiiiiiiii ddddd"
    "movz $r$rd, #$imm, LSL #$shift"
    (names (size s) (imm i) (rd d) (hw h))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shift (<< (u32 hw) 4)))
    (if (== size 0)
        (= (gpr32 rd) (<< (u32 imm) shift))
        (= (gpr64 rd) (<< (u64 imm) shift))))

(def MRS
    "1101010100 1 1 o ppp nnnn mmmm qqq ttttt"
    "mrs S$op0 $op1 $cn $cm $op2, X$rt"
    (names (op0 o) (op1 p) (cn n) (cm m) (op2 q) (rt t))
    (block)
    (= (gpr64 rt) (sr op0 op1 cn cm op2)))

(def MSR-register
    "1101010100 0 1 o ppp nnnn mmmm qqq ttttt"
    "msr S$op0 $op1 $cn $cm $op2, X$rt"
    (names (op0 o) (op1 p) (cn n) (cm m) (op2 q) (rt t))
    (block)
    (= (sr op0 op1 cn cm op2) (gpr64 rt)))

(def MSUB
    "s 00 11011 000 mmmmm 1 aaaaa nnnnn ddddd"
    "msub $r$rd, $r$rn, $r$rm, $r$ra"
    (names (size s) (rm m) (ra a) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (- (gpr32 ra) (* (gpr32 rn) (gpr32 rm))))
        (= (gpr64 rd) (- (gpr64 ra) (* (gpr64 rn) (gpr64 rm))))))

(def MUL-by-element
    "0 Q 0 01111 ss L M vvvv 1000 H 0 nnnnn ddddd"
    "mul V$rd.$t, V$rn.$t, V$rm.$ts[$index]"
    (names (Q Q) (size s) (L L) (M M) (rv v) (H H) (rn n) (rd d))
    (block
        (let rm (if (== size 0b10) (: M rv) rv))
        (let t (match (: size Q)
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            (unimplemented)))
        (let ts (match size
            0b01 "H"
            0b10 "S"
            (unimplemented)))
        (let index (match size
            0b01 (: H L M)
            0b10 (: H L)
            (unimplemented))))
    (let v (match size
                0b01 (vec-uint* (vec rn) (vector-element (vec rm) index u16) 16)
                0b10 (vec-uint* (vec rn) (vector-element (vec rm) index u32) 32)
                (unimplemented))
            (= (vec rd) (if Q v (vector-zero-top v)))))

(def MUL-vector
    "0 Q 0 01110 ss 1 mmmmm 10011 1 nnnnn ddddd"
    "mul V$rd.$t, V$rn.$t, V$rm.$t"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let t (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        (unimplemented)))
    (let v (match size
            0b00 (vec-uint* (vec rn) (vec rm) 8)
            0b01 (vec-uint* (vec rn) (vec rm) 16)
            0b10 (vec-uint* (vec rn) (vec rm) 32)
            (unimplemented))
        (= (vec rd) (if Q v (vector-zero-top v)))))

(def MVNI-vector-16bit
    "0 Q 1 0111100000 a b c 10m0 0 1 d e f g h rrrrr"
    "mvni V$rd.$t, #$imm, LSL #$amount"
    (names (Q Q) (cmode m) (a a) (b b) (c c) (d d) (e e) (f f) (g g) (h h) (rd r))
    (block
        (let t (if Q "8H" "4H"))
        (let imm (: a b c d e f g h))
        (let amount (if cmode 8 0)))
    (let avec (vector-all (u16 (~ (<< (u16 imm) amount))))
        (= (vec rd) (if Q avec (vector-zero-top avec)))))

(def MVNI-vector-32bit-LSL
    "0 Q 1 0111100000 a b c 0mm0 0 1 d e f g h rrrrr"
    "mvni V$rd.$t, #$imm, LSL #$amount"
    (names (Q Q) (cmode m) (a a) (b b) (c c) (d d) (e e) (f f) (g g) (h h) (rd r))
    (block
        (let t (if Q "4S" "2S"))
        (let amount (match cmode
            0b00 0
            0b01 8
            0b10 16
            0b11 24
            (unimplemented)))
        (let imm (: a b c d e f g h)))
    (let avec (vector-all (~ (<< (u32 imm) amount)))
        (= (vec rd) (if Q avec (vector-zero-top avec)))))

(def MVNI-vector-32bit-MSL
    "0 Q 1 0111100000 a b c 110m 0 1 d e f g h rrrrr"
    "mvni V$rd.$t, #$imm, MSL #$amount"
    (names (Q Q) (cmode m) (a a) (b b) (c c) (d d) (e e) (f f) (g g) (h h) (rd r))
    (block
        (let t (if Q "4S" "2S"))
        (let amount (if cmode 16 8))
        (let imm (: a b c d e f g h)))
    (let avec (vector-all (~ (| (<< (u32 imm) amount) (u32 (if cmode 0xFFFF 0xFF)))))
        (= (vec rd) (if Q avec (vector-zero-top avec)))))

(def NEG-vector
    "0 Q 1 01110 ss 10000 01011 10 nnnnn ddddd"
    "neg V$rd.$t, V$rn.$t"
    (names (Q Q) (size s) (rn n) (rd d))
    (let t (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        0b11_1 "2D"
        (unimplemented)))
    (let n (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (match (: size Q)
            0b00_0 (block
                    (vector-insert rd 0 (-! (vector-element n 0 i8))) (vector-insert rd 1 (-! (vector-element n 1 i8)))
                    (vector-insert rd 2 (-! (vector-element n 2 i8))) (vector-insert rd 3 (-! (vector-element n 3 i8)))
                    (vector-insert rd 4 (-! (vector-element n 4 i8))) (vector-insert rd 5 (-! (vector-element n 5 i8)))
                    (vector-insert rd 6 (-! (vector-element n 6 i8))) (vector-insert rd 7 (-! (vector-element n 7 i8))))
            0b00_1 (block
                    (vector-insert rd  0 (-! (vector-element n  0 i8))) (vector-insert rd  1 (-! (vector-element n  1 i8)))
                    (vector-insert rd  2 (-! (vector-element n  2 i8))) (vector-insert rd  3 (-! (vector-element n  3 i8)))
                    (vector-insert rd  4 (-! (vector-element n  4 i8))) (vector-insert rd  5 (-! (vector-element n  5 i8)))
                    (vector-insert rd  6 (-! (vector-element n  6 i8))) (vector-insert rd  7 (-! (vector-element n  7 i8)))
                    (vector-insert rd  8 (-! (vector-element n  8 i8))) (vector-insert rd  9 (-! (vector-element n  9 i8)))
                    (vector-insert rd 10 (-! (vector-element n 10 i8))) (vector-insert rd 11 (-! (vector-element n 11 i8)))
                    (vector-insert rd 12 (-! (vector-element n 12 i8))) (vector-insert rd 13 (-! (vector-element n 13 i8)))
                    (vector-insert rd 14 (-! (vector-element n 14 i8))) (vector-insert rd 15 (-! (vector-element n 15 i8))))
            0b01_0 (block
                    (vector-insert rd 0 (-! (vector-element n 0 i16))) (vector-insert rd 1 (-! (vector-element n 1 i16)))
                    (vector-insert rd 2 (-! (vector-element n 2 i16))) (vector-insert rd 3 (-! (vector-element n 3 i16))))
            0b01_1 (block
                    (vector-insert rd 0 (-! (vector-element n 0 i16))) (vector-insert rd 1 (-! (vector-element n 1 i16)))
                    (vector-insert rd 2 (-! (vector-element n 2 i16))) (vector-insert rd 3 (-! (vector-element n 3 i16)))
                    (vector-insert rd 4 (-! (vector-element n 4 i16))) (vector-insert rd 5 (-! (vector-element n 5 i16)))
                    (vector-insert rd 6 (-! (vector-element n 6 i16))) (vector-insert rd 7 (-! (vector-element n 7 i16))))
            0b10_0 (block
                    (vector-insert rd 0 (-! (vector-element n 0 i32))) (vector-insert rd 1 (-! (vector-element n 1 i32))))
            0b10_1 (block
                    (vector-insert rd 0 (-! (vector-element n 0 i32))) (vector-insert rd 1 (-! (vector-element n 1 i32)))
                    (vector-insert rd 2 (-! (vector-element n 2 i32))) (vector-insert rd 3 (-! (vector-element n 3 i32))))
            0b11_1 (block
                    (vector-insert rd 0 (-! (vector-element n 0 i64))) (vector-insert rd 1 (-! (vector-element n 1 i64))))
            (unimplemented))))

(def NOP
    "1101010100 0 00 011 0010 0000 000 11111"
    "nop"
    (names)
    (block)
    (block))

(def ORN-shifted-register
    "f 01 01010 ss 1 mmmmm iiiiii nnnnn ddddd"
    "orn $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm (if size 63 31)))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
            (= (gpr32 rd) (| (gpr32 rn) (~ (do-shift32 (gpr32 rm) shift imm))))
            (= (gpr64 rd) (| (gpr64 rn) (~ (do-shift64 (gpr64 rm) shift imm))))))

(def ORR-immediate
    "f 01 100100 u iiiiii ssssss nnnnn ddddd"
    "orr $r$rd, $r$rn, #$imm"
    (names (size f) (up u) (immr i) (imms s) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (make-wmask up imms immr 1 (if (== size 0) 32 64))))
    (if (== size 0)
        (= (gpr-or-sp32 rd) (| (gpr32 rn) (u32 imm)))
        (= (gpr-or-sp64 rd) (| (gpr64 rn) imm))))

(def ORR-shifted-register
    "f 01 01010 ss 0 mmmmm iiiiii nnnnn ddddd"
    "orr $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm (if size 63 31)))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
        (= (gpr32 rd) (| (gpr32 rn) (do-shift32 (gpr32 rm) shift imm)))
        (= (gpr64 rd) (| (gpr64 rn) (do-shift64 (gpr64 rm) shift imm)))))

(def ORR-simd-register
    "0 Q 0 01110 10 1 mmmmm 00011 1 nnnnn ddddd"
    "orr V$rd.$t, V$rn.$t, V$rm.$t"
    (names (Q Q) (rm m) (rn n) (rd d))
    (let t (if (== Q 0) "8B" "16B"))
    (= (vec rd) (zero-if Q (if (== rm rn)
        (vec rn)
        (vec| (vec rn) (vec rm)))))) 

(def PMULL[2]
    "0 Q 0 01110 ss 1 mmmmm 1110 00 nnnnn ddddd"
    "pmull$h V$rd.$Ta, V$rn.$Tb, V$rm.$Tb"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let h (if Q "2" "")
        (let Ta (match size
            0b00 "8H"
            0b11 "1Q"
            (unimplemented)))
        (let Tb (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b11_0 "1D"
            0b11_1 "2D"
            (unimplemented))))
    (if (== size 0b11)
        (block
            (polynomial* (vector-element (vec rn) Q u64) (vector-element (vec rm) Q u64) 64 u128)
            (= (vec rd) (bitcast result vec)))
        (unimplemented)))

(def PRFM-immediate
    "11 111 0 01 10 iiiiiiiiiiii nnnnn ttttt"
    "prfm #$imm5, [X$rn, #$pimm]"
    (names (imm i) (rn n) (imm5 t))
    (let pimm (* imm 8))
    (block))

(def PRFM-literal
    "11 011 0 00 iiiiiiiiiiiiiiiiiii ttttt"
    "prfm TODO"
    (names (imm i) (rt t))
    (block)
    (block))

(def PRFM-register
    "11 111 0 00 10 1 mmmmm ooo S 10 nnnnn ttttt"
    "prfm TODO"
    (names (rm m) (opt o) (S S) (rn n) (rt t))
    (block)
    (block))

(def PRFUM
    "11 111 0 00 10 0 iiiiiiiii 00 nnnnn ttttt"
    "prfum TODO"
    (names (imm i) (rn n) (rt t))
    (block)
    (block))

(def RBIT
    "s 1 0 11010110 00000 0000 00 nnnnn ddddd"
    "rbit $r$rd, $r$rn"
    (names (size s) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (reverse-bits (gpr32 rn)))
        (= (gpr64 rd) (reverse-bits (gpr64 rn)))))

(def RET
    "1101011 0 0 10 11111 0000 0 0 nnnnn 00000"
    "ret X$rn"
    (names (rn n))
    (block)
    (branch-register rn))

(def REV
    "s 1 0 11010110 00000 0000 1o nnnnn ddddd"
    "rev $r$rd, $r$rn"
    (names (size s) (opc o) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (match (: size opc)
        0b00 (let x (gpr32 rn) (= (gpr32 rd) (|
            (<< (& x         0xFF) 24)
            (<< (& (>> x 8)  0xFF) 16)
            (<< (& (>> x 16) 0xFF) 8)
                (& (>> x 24) 0xFF))))
        0b11 (let x (gpr64 rn) (= (gpr64 rd) (|
            (<< (& x          0xFF) 56)
            (<< (& (>> x 8)   0xFF) 48)
            (<< (& (>> x 16)  0xFF) 40)
            (<< (& (>> x 24)  0xFF) 32)
            (<< (& (>> x 32)  0xFF) 24)
            (<< (& (>> x 40)  0xFF) 16)
            (<< (& (>> x 48)  0xFF) 8)
                (& (>> x 56)  0xFF))))
        (unimplemented)))

(def REV16
    "s 1 0 11010110 00000 0000 01 nnnnn ddddd"
    "rev16 $r$rd, $r$rn"
    (names (size s) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (let x (gpr32 rn) (= (gpr32 rd) (|
            (<< (& x         0xFF) 8)
                (& (>> x 8)  0xFF)
            (<< (& (>> x 16) 0xFF) 24)
            (<< (& (>> x 24) 0xFF) 16))))
        (let x (gpr64 rn) (= (gpr64 rd) (|
            (<< (& x         0xFF) 8)
                (& (>> x 8)  0xFF)
            (<< (& (>> x 16) 0xFF) 24)
            (<< (& (>> x 24) 0xFF) 16)

            (<< (& (>> x 32) 0xFF) 40)
            (<< (& (>> x 40) 0xFF) 32)
            (<< (& (>> x 48) 0xFF) 56)
            (<< (& (>> x 56) 0xFF) 48))))))

(def RORV
    "s 0 0 11010110 mmmmm 0010 11 nnnnn ddddd"
    "rorv $r$rd, $r$rn, $r$rm"
    (names (size s) (rm m) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (>>> (gpr32 rn) (% (gpr32 rm) 32)))
        (= (gpr64 rd) (>>> (gpr64 rn) (% (gpr64 rm) 64)))))

(def SBCS
    "s 1 1 11010000 mmmmm 000000 nnnnn ddddd"
    "sbcs $r$rd, $r$rn, $r$rm"
    (names (size s) (rm m) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (add-with-carry-set-nzcv32 (gpr32 rn) (~ (gpr32 rm)) (nzcv c)))
        (= (gpr64 rd) (add-with-carry-set-nzcv64 (gpr64 rn) (~ (gpr64 rm)) (nzcv c)))))

(def SBFM
    "f 00 100110 o pppppp ssssss nnnnn ddddd"
    "sbfm $r$rd, $r$rn, #$immr, #$imms"
    (names (N o) (size f) (immr p) (imms s) (rn n) (rd d))
    (block
        (requires (<= imms (if size 63 31)))
        (requires (<= immr (if size 63 31)))
        (if size
            (requires N)
            (requires (== N 0)))
        (let r (if (== size 0) "W" "X")))
    (if (== size 0)
        (block
            (let src (gpr32 rn))
            (let wmask (u32 (make-wmask N imms immr 0 32)))
            (let tmask (u32 (make-tmask N imms immr 0 32)))
            (let bot (& (>>> src immr) wmask))
            (let top (- (u32 0) (& (>> src imms) 1)))
            (= (gpr32 rd) (| (& top (~ tmask)) (& bot tmask))))
        (block
            (let src (gpr64 rn))
            (let wmask (make-wmask N imms immr 0 64))
            (let tmask (make-tmask N imms immr 0 64))
            (let bot (& (>>> src immr) wmask))
            (let top (- (u64 0) (& (>> src imms) 1)))
            (= (gpr64 rd) (| (& top (~ tmask)) (& bot tmask))))))

(def SCVTF-scalar-integer
    "s 0 0 11110 tt 1 00 010 000000 nnnnn ddddd"
    "scvtf $r1$rd, $r2$rn"
    (names (size s) (type t) (rn n) (rd d))
    (block
        (let st (: size type))
        (let r1 "") (let r2 "")
        (match st
            0b0_11 (block (= r1 "H") (= r2 "W"))
            0b0_00 (block (= r1 "S") (= r2 "W"))
            0b0_01 (block (= r1 "D") (= r2 "W"))
            0b1_11 (block (= r1 "H") (= r2 "X"))
            0b1_00 (block (= r1 "S") (= r2 "X"))
            0b1_01 (block (= r1 "D") (= r2 "X"))
            (unimplemented)))
    (match st
        0b0_00 (= (vec-s rd) (f32 (i32 (gpr32 rn))))
        0b0_01 (= (vec-d rd) (f64 (i32 (gpr32 rn))))
        0b1_00 (= (vec-s rd) (f32 (i64 (gpr64 rn))))
        0b1_01 (= (vec-d rd) (f64 (i64 (gpr64 rn))))
        (unimplemented)))

(def SCVTF-scalar
    "01 0 11110 0 s 10000 11101 10 nnnnn ddddd"
    "scvtf $r$rd, $r$rn"
    (names (size s) (rn n) (rd d))
    (let r (if (== size 0) "S" "D"))
    (if (== size 0)
        (= (vec-s rd) (f32 (bitcast (vec-s rn) i32)))
        (= (vec-d rd) (f64 (bitcast (vec-d rn) i64)))))

(def SCVTF-vector
    "0 Q 0 01110 0 s 10000 11101 10 nnnnn ddddd"
    "scvtf V$rd.$t, V$rn.$t"
    (names (Q Q) (size s) (rn n) (rd d))
    (let t (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (let n (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (match (: size Q)
            0b00 (block
                    (vector-insert rd 0 (f32 (vector-element n 0 i32)))
                    (vector-insert rd 1 (f32 (vector-element n 1 i32))))
            0b01 (block
                    (vector-insert rd 0 (f32 (vector-element n 0 i32)))
                    (vector-insert rd 1 (f32 (vector-element n 1 i32)))
                    (vector-insert rd 2 (f32 (vector-element n 2 i32)))
                    (vector-insert rd 3 (f32 (vector-element n 3 i32))))
            0b11 (block
                    (vector-insert rd 0 (f64 (vector-element n 0 i64)))
                    (vector-insert rd 1 (f64 (vector-element n 1 i64))))
            (unimplemented))))

(def SDIV
    "f 0 0 11010110 mmmmm 00001 1 nnnnn ddddd"
    "sdiv $r$rd, $r$rn, $r$rm"
    (names (size f) (rm m) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (let operand2 (gpr32 rm)
            (= (gpr32 rd) (if (== operand2 0)
                (u32 0)
                (u32 (/ (i32 (gpr32 rn)) (i32 operand2))))))
        (let operand2 (gpr64 rm)
            (= (gpr64 rd) (if (== operand2 0)
                (u64 0)
                (u64 (/ (i64 (gpr64 rn)) (i64 operand2))))))))

(defm shl-elem (i type)
    (vector-insert rd i (<< (vector-element sv i type) shift)))

(def SHL-vector
    "0 Q 0 011110 hhhh bbb 01010 1 nnnnn ddddd"
    "shl V$rd.$T, V$rn.$T, #$shift"
    (names (Q Q) (immh h) (immb b) (rn n) (rd d))
    (mlet (T "" size 0 shift 0)
        (requires (!= immh 0b0000))
        (if (== immh 0b0001)            (block (= T (if Q "16B" "8B")) (= size 1) (= shift (- (u32 (: immh immb)) 8)))
        (if (== (& immh 0b1110) 0b0010) (block (= T (if Q "8H" "4H")) (= size 2) (= shift (- (u32 (: immh immb)) 16)))
        (if (== (& immh 0b1100) 0b0100) (block (= T (if Q "4S" "2S")) (= size 4) (= shift (- (u32 (: immh immb)) 32)))
                                        (block (= T (if Q "2D" (unimplemented))) (= size 8) (= shift (- (u32 (: immh immb)) 64)))))))
    (let sv (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (match size
            1 (block
                (shl-elem 0 u8) (shl-elem 1 u8)
                (shl-elem 2 u8) (shl-elem 3 u8)
                (shl-elem 4 u8) (shl-elem 5 u8)
                (shl-elem 6 u8) (shl-elem 7 u8)
                (when Q
                    (shl-elem 8  u8) (shl-elem 9  u8)
                    (shl-elem 10 u8) (shl-elem 11 u8)
                    (shl-elem 12 u8) (shl-elem 13 u8)
                    (shl-elem 14 u8) (shl-elem 15 u8)))
            2 (block
                (shl-elem 0 u16) (shl-elem 1 u16)
                (shl-elem 2 u16) (shl-elem 3 u16)
                (when Q
                    (shl-elem 4 u16) (shl-elem 5 u16)
                    (shl-elem 6 u16) (shl-elem 7 u16)))
            4 (block
                (shl-elem 0 u32) (shl-elem 1 u32)
                (when Q
                    (shl-elem 2 u32) (shl-elem 3 u32)))
              (block (shl-elem 0 u64) (shl-elem 1 u64)))))

(def SMADDL
    "1 00 11011 0 01 mmmmm 0 aaaaa nnnnn ddddd"
    "smaddl X$rd, W$rn, W$rm, X$ra"
    (names (rd d) (rn n) (rm m) (ra a))
    (block)
    (= (gpr64 rd) (u64 (+ (i64 (gpr64 ra)) (* (signext (gpr32 rn) i64) (signext (gpr32 rm) i64))))))

(def SMULH
    "1 00 11011 0 10 mmmmm 0 11111 nnnnn ddddd"
    "smulh X$rd, X$rn, X$rm"
    (names (rm m) (rn n) (rd d))
    (block)
    (= (gpr64 rd) (u64 (i64 (>> (* (cast (i64 (gpr64 rn)) i128) (cast (i64 (gpr64 rm)) i128)) 64)))))

(defm sshll-elem (i offset type etype)
    (vector-insert rd i (<< (etype (vector-element iv (u32 (if Q (+ i offset) i)) type)) shift)))

(def SSHLL
    "0 Q 0 011110 hhhh bbb 10100 1 nnnnn ddddd"
    "sshll$variant V$rd.$ta, V$rn.$tb, #$shift"
    (names (Q Q) (immh h) (immb b) (rn n) (rd d))
    (mlet (variant (if Q "2" "") ta "" tb "" shift (u64 0))
        (if (== immh 0b0001) (block
            (= ta "8H") (= tb (if Q "16B" "8B"))
            (= shift (- (: immh immb) 8)))
        (if (== (& immh 0b1110) 0b0010) (block
            (= ta "4S") (= tb (if Q "8H" "4H"))
            (= shift (- (: immh immb) 16)))
        (if (== (& immh 0b1100) 0b0100) (block
            (= ta "2D") (= tb (if Q "4S" "2S"))
            (= shift (- (: immh immb) 32)))
        (unimplemented)))))
    (let iv (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (if (== immh 0b0001) (block
            (sshll-elem 0 8 i8 i16)
            (sshll-elem 1 8 i8 i16)
            (sshll-elem 2 8 i8 i16)
            (sshll-elem 3 8 i8 i16)
            (sshll-elem 4 8 i8 i16)
            (sshll-elem 5 8 i8 i16)
            (sshll-elem 6 8 i8 i16)
            (sshll-elem 7 8 i8 i16))
        (if (== (& immh 0b1110) 0b0010) (block
            (sshll-elem 0 4 i16 i32)
            (sshll-elem 1 4 i16 i32)
            (sshll-elem 2 4 i16 i32)
            (sshll-elem 3 4 i16 i32))
        (if (== (& immh 0b1100) 0b0100) (block
            (sshll-elem 0 2 i32 i64)
            (sshll-elem 1 2 i32 i64))
        (unimplemented))))))

(defm st1-sub (size type) (store (+ address (literal (* i size))) (vector-element v i type)))

(def ST1-multi-no-offset-one-register
    "0 Q 0011000 0 000000 0111 ss nnnnn ttttt"
    "st1 { V$rt.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (let T (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        0b11_1 "2D"
        (unimplemented)))
    (mlet (address (gpr-or-sp64 rn) v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))))

(def ST1-multi-postindex-immediate-one-register
    "0 Q 0011001 0 0 mmmmm 0111 ss nnnnn ttttt"
    "st1 { V$rt.$T }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (let imm (u8 (if Q 16 8))
        (requires (== rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def ST1-multi-postindex-register-one-register
    "0 Q 0011001 0 0 mmmmm 0111 ss nnnnn ttttt"
    "st1 { V$rt.$T }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (block
        (requires (!= rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address (gpr64 rm)))))

(def ST1-multi-no-offset-two-registers
    "0 Q 0011000 0 000000 1010 ss nnnnn ttttt"
    "st1 { V$rt.$T, V$rt2.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (let rt2 (% (+ rt 1) 32)
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))))

(def ST1-multi-postindex-immediate-two-registers
    "0 Q 0011001 0 0 mmmmm 1010 ss nnnnn ttttt"
    "st1 { V$rt.$T, V$rt2.$T }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (imm (u8 (if Q 32 16)) rt2 (% (+ rt 1) 32))
        (requires (== rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address (if Q 16 8)))))

(def ST1-multi-postindex-register-two-registers
    "0 Q 0011001 0 0 mmmmm 1010 ss nnnnn ttttt"
    "st1 { V$rt.$T, V$rt2.$T }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (let rt2 (% (+ rt 1) 32)
        (requires (!= rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) oaddress address v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ oaddress (gpr64 rm)))))

(def ST1-multi-no-offset-three-registers
    "0 Q 0011000 0 000000 0110 ss nnnnn ttttt"
    "st1 { V$rt.$T, V$rt2.$T, V$rt3.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt3))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))))

(def ST1-multi-postindex-immediate-three-registers
    "0 Q 0011001 0 0 mmmmm 0110 ss nnnnn ttttt"
    "st1 { V$rt.$T, V$rt2.$T, V$rt3.$T }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (imm (u8 (if Q 48 24)) rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32))
        (requires (== rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt3))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address (if Q 16 8)))))

(def ST1-multi-postindex-register-three-registers
    "0 Q 0011001 0 0 mmmmm 0110 ss nnnnn ttttt"
    "st1 { V$rt.$T, V$rt2.$T, V$rt3.$T }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32))
        (requires (!= rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) oaddress address v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt3))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ oaddress (gpr64 rm)))))

(def ST1-multi-no-offset-four-registers
    "0 Q 0011000 0 000000 0010 ss nnnnn ttttt"
    "st1 { V$rt.$T, V$rt2.$T, V$rt3.$T, V$rt4.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) rt4 (% (+ rt 3) 32))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt3))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt4))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))))

(def ST1-multi-postindex-immediate-four-registers
    "0 Q 0011001 0 0 mmmmm 0010 ss nnnnn ttttt"
    "st1 { V$rt.$T, V$rt2.$T, V$rt3.$T, V$rt4.$T }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (imm (u8 (if Q 64 32)) rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) rt4 (% (+ rt 3) 32))
        (requires (== rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt3))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt4))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address (if Q 16 8)))))

(def ST1-multi-postindex-register-four-registers
    "0 Q 0011001 0 0 mmmmm 0010 ss nnnnn ttttt"
    "st1 { V$rt.$T, V$rt2.$T, V$rt3.$T, V$rt4.$T }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) rt4 (% (+ rt 3) 32))
        (requires (!= rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) oaddress address v (vec rt))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt3))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= address (+ address (if Q 16 8)))
        (= v (vec rt4))
        (match size
            0b00 (qfor i 8 16 (st1-sub 1 u8))
            0b01 (qfor i 4  8 (st1-sub 2 u16))
            0b10 (qfor i 2  4 (st1-sub 4 f32))
                 (for (i 2)   (st1-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ oaddress (gpr64 rm)))))

(def ST1-single-no-offset
    "0 Q 0011010 0 0 00000 xx0 S zz nnnnn ttttt"
    "st1 { V$rt.$t }[$index], [X$rn]"
    (names (Q Q) (opc x) (S S) (size z) (rn n) (rt t))
    (block
        (requires (!= opc 0b11))
        (let t (if (== opc 0b00)
            "B"
            (if (& (== opc 0b01) (== (& size 1) 0))
                "H"
                (if (== opc 0b10)
                    (if (== size 0b00)
                        "S"
                        (if (& (== size 0b01) (== S 0))
                            "D"
                            (unimplemented)))
                    (unimplemented)))))
        (let index (match opc
            0b00 (u32 (: Q S size))
            0b01 (>> (u32 (: Q S size)) 1)
            0b10 (if (== (& size 1) 0)
                (u32 (: Q S))
                Q)
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) v (vec rt))
        (match opc
            0b00 (store address (vector-element v index u8))
            0b01 (store address (vector-element v index u16))
            0b10 (if (== size 0b00)
                (store address (vector-element v index f32))
                (store address (vector-element v index f64)))
            (unimplemented))))

(defm st2-sub (size type) (block
    (store (+ address (literal (* i (* size 2)))) (vector-element a i type))
    (store (+ address (literal (+ size (* i (* size 2))))) (vector-element b i type))))

(def ST2-multi-no-offset
    "0 Q 0011000 0 000000 1000 ss nnnnn ttttt"
    "st2 { V$rt.$T, V$rt2.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (let rt2 (% (+ rt 1) 32)
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) a (vec rt) b (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st2-sub 1 u8))
            0b01 (qfor i 4  8 (st2-sub 2 u16))
            0b10 (qfor i 2  4 (st2-sub 4 f32))
                 (for (i 2)   (st2-sub 8 f64)))))

(def ST2-multi-postindex-immediate
    "0 Q 0011001 0 0 mmmmm 1000 ss nnnnn ttttt"
    "st2 { V$rt.$T, V$rt2.$T }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) imm (u8 (if Q 32 16)))
        (requires (== rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) a (vec rt) b (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st2-sub 1 u8))
            0b01 (qfor i 4  8 (st2-sub 2 u16))
            0b10 (qfor i 2  4 (st2-sub 4 f32))
                 (for (i 2)   (st2-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def ST2-multi-postindex-register
    "0 Q 0011001 0 0 mmmmm 1000 ss nnnnn ttttt"
    "st2 { V$rt.$T, V$rt2.$T }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (let rt2 (% (+ rt 1) 32)
        (requires (!= rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) a (vec rt) b (vec rt2))
        (match size
            0b00 (qfor i 8 16 (st2-sub 1 u8))
            0b01 (qfor i 4  8 (st2-sub 2 u16))
            0b10 (qfor i 2  4 (st2-sub 4 f32))
                 (for (i 2)   (st2-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address (gpr64 rm)))))

(defm st3-sub (size type) (block
    (store (+ address (literal (* i (* size 3)))) (vector-element a i type))
    (store (+ address (literal (+ size (* i (* size 3))))) (vector-element b i type))
    (store (+ address (literal (+ (* 2 size) (* i (* size 3))))) (vector-element c i type))))

(def ST3-multi-no-offset
    "0 Q 0011000 0 000000 0100 ss nnnnn ttttt"
    "st3 { V$rt.$T, V$rt2.$T, V$rt3.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) a (vec rt) b (vec rt2) c (vec rt3))
        (match size
            0b00 (qfor i 8 16 (st3-sub 1 u8))
            0b01 (qfor i 4  8 (st3-sub 2 u16))
            0b10 (qfor i 2  4 (st3-sub 4 f32))
                 (for (i 2)   (st3-sub 8 f64)))))

(def ST3-multi-postindex-immediate
    "0 Q 0011001 0 0 mmmmm 0100 ss nnnnn ttttt"
    "st3 { V$rt.$T, V$rt2.$T, V$rt3.$T }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) imm (u8 (if Q 48 24)))
        (requires (== rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) a (vec rt) b (vec rt2) c (vec rt3))
        (match size
            0b00 (qfor i 8 16 (st3-sub 1 u8))
            0b01 (qfor i 4  8 (st3-sub 2 u16))
            0b10 (qfor i 2  4 (st3-sub 4 f32))
                 (for (i 2)   (st3-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def ST3-multi-postindex-register
    "0 Q 0011001 0 0 mmmmm 0100 ss nnnnn ttttt"
    "st3 { V$rt.$T, V$rt2.$T, V$rt3.$T }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32))
        (requires (!= rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) a (vec rt) b (vec rt2) c (vec rt3))
        (match size
            0b00 (qfor i 8 16 (st3-sub 1 u8))
            0b01 (qfor i 4  8 (st3-sub 2 u16))
            0b10 (qfor i 2  4 (st3-sub 4 f32))
                 (for (i 2)   (st3-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address (gpr64 rm)))))

(defm st4-sub (size type) (block
    (store (+ address (literal (* i (* size 4)))) (vector-element a i type))
    (store (+ address (literal (+ size (* i (* size 4))))) (vector-element b i type))
    (store (+ address (literal (+ (* 2 size) (* i (* size 4))))) (vector-element c i type))
    (store (+ address (literal (+ (* 3 size) (* i (* size 4))))) (vector-element d i type))))

(def ST4-multi-no-offset
    "0 Q 0011000 0 000000 0000 ss nnnnn ttttt"
    "st4 { V$rt.$T, V$rt2.$T, V$rt3.$T, V$rt4.$T }, [X$rn]"
    (names (Q Q) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) rt4 (% (+ rt 3) 32))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) a (vec rt) b (vec rt2) c (vec rt3) d (vec rt4))
        (match size
            0b00 (qfor i 8 16 (st4-sub 1 u8))
            0b01 (qfor i 4  8 (st4-sub 2 u16))
            0b10 (qfor i 2  4 (st4-sub 4 f32))
                 (for (i 2)   (st4-sub 8 f64)))))

(def ST4-multi-postindex-immediate
    "0 Q 0011001 0 0 mmmmm 0000 ss nnnnn ttttt"
    "st4 { V$rt.$T, V$rt2.$T, V$rt3.$T, V$rt4.$T }, [X$rn], #$imm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) rt4 (% (+ rt 3) 32) imm (u8 (if Q 64 43)))
        (requires (== rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) a (vec rt) b (vec rt2) c (vec rt3) d (vec rt4))
        (match size
            0b00 (qfor i 8 16 (st4-sub 1 u8))
            0b01 (qfor i 4  8 (st4-sub 2 u16))
            0b10 (qfor i 2  4 (st4-sub 4 f32))
                 (for (i 2)   (st4-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address imm))))

(def ST4-multi-postindex-register
    "0 Q 0011001 0 0 mmmmm 0000 ss nnnnn ttttt"
    "st4 { V$rt.$T, V$rt2.$T, V$rt3.$T, V$rt4.$T }, [X$rn], X$rm"
    (names (Q Q) (rm m) (size s) (rn n) (rt t))
    (mlet (rt2 (% (+ rt 1) 32) rt3 (% (+ rt 2) 32) rt4 (% (+ rt 3) 32))
        (requires (!= rm 0b11111))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (address (gpr-or-sp64 rn) a (vec rt) b (vec rt2) c (vec rt3) d (vec rt4))
        (match size
            0b00 (qfor i 8 16 (st4-sub 1 u8))
            0b01 (qfor i 4  8 (st4-sub 2 u16))
            0b10 (qfor i 2  4 (st4-sub 4 f32))
                 (for (i 2)   (st4-sub 8 f64)))
        (= (gpr-or-sp64 rn) (+ address (gpr64 rm)))))

(def STLR
    "1f 001000 1 0 0 11111 1 11111 nnnnn ttttt"
    "stlr $r$rt, [X$rn]"
    (names (size f) (rn n) (rt t))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (store (gpr-or-sp64 rn) (gpr32 rt))
        (store (gpr-or-sp64 rn) (gpr64 rt))))

(def STLRB
    "00 001000 1 0 0 11111 1 11111 nnnnn ttttt"
    "stlrb W$rt, [X$rn]"
    (names (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (store address (u8 (gpr32 rt)))))

(def STLRH
    "01 001000 1 0 0 11111 1 11111 nnnnn ttttt"
    "stlrh W$rt, [X$rn]"
    (names (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (store address (u16 (gpr32 rt)))))

(def STLXR
    "1f 001000 0 0 0 sssss 1 11111 nnnnn ttttt"
    "stlxr W$rs, $r$rt, [X$rn]"
    (names (size f) (rs s) (rn n) (rt t))
    (let r (if (== size 0) "W" "X"))
    (let address (gpr-or-sp64 rn)
        (if (== size 0)
            (store address (gpr32 rt))
            (store address (gpr64 rt)))
        (= (gpr32 rs) 0)))

(def STLXRB
    "00 001000 0 0 0 sssss 1 11111 nnnnn ttttt"
    "stlxrr W$rs, W$rt, [X$rn]"
    (names (rs s) (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (store address (u8 (gpr32 rt)))
        (= (gpr32 rs) 0)))

(def STP-postindex
    "s0 101 0 001 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd], #$simm"
    (names (size s) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (if (== size 0) "W" "X"))
        (let simm (<< (signext imm i64) (if (== size 0) 2 3))))
    (let address (gpr-or-sp64 rd)
        (if (== size 0)
            (block
                (store address (gpr32 rt1))
                (store (+ address 4) (gpr32 rt2)))
            (block
                (store address (gpr64 rt1))
                (store (+ address 8) (gpr64 rt2))))
        (= (gpr-or-sp64 rd) (+ address simm))))

(def STP-preindex
    "s0 101 0 011 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd, #$simm]!"
    (names (size s) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (if (== size 0) "W" "X"))
        (let simm (<< (signext imm i64) (if (== size 0) 2 3))))
    (let address (+ (gpr-or-sp64 rd) simm)
        (if (== size 0)
            (block
                (store address (gpr32 rt1))
                (store (+ address 4) (gpr32 rt2)))
            (block
                (store address (gpr64 rt1))
                (store (+ address 8) (gpr64 rt2))))
        (= (gpr-or-sp64 rd) address)))

(def STP-signed-offset
    "s0 101 0 010 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd, #$simm]"
    (names (size s) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (if (== size 0) "W" "X"))
        (let simm (<< (signext imm i64) (if (== size 0) 2 3))))
    (let address (+ (gpr-or-sp64 rd) simm)
        (if (== size 0)
            (block
                (store address (gpr32 rt1))
                (store (+ address 4) (gpr32 rt2)))
            (block
                (store address (gpr64 rt1))
                (store (+ address 8) (gpr64 rt2))))))

(def STP-simd-postindex
    "oo 101 1 001 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd], #$simm"
    (names (opc o) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (match opc 0b00 "S" 0b01 "D" 0b10 "Q" (unimplemented)))
        (let simm (<< (signext imm i64) (match opc 0b00 2 0b01 3 0b10 4 (unimplemented)))))
    (let address (gpr-or-sp64 rd)
        (match opc
            0b00 (block
                (store address (vec-s rt1))
                (store (+ address 4) (vec-s rt2)))
            0b01 (block
                (store address (vec-d rt1))
                (store (+ address 8) (vec-d rt2)))
            0b10 (block
                (store address (vec rt1))
                (store (+ address 16) (vec rt2)))
            (unimplemented))
        (= (gpr-or-sp64 rd) (+ address simm))))

(def STP-simd-preindex
    "oo 101 1 011 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd, #$simm]!"
    (names (opc o) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (match opc 0b00 "S" 0b01 "D" 0b10 "Q" (unimplemented)))
        (let simm (<< (signext imm i64) (match opc 0b00 2 0b01 3 0b10 4 (unimplemented)))))
    (let address (+ (gpr-or-sp64 rd) simm)
        (match opc
            0b00 (block
                (store address (vec-s rt1))
                (store (+ address 4) (vec-s rt2)))
            0b01 (block
                (store address (vec-d rt1))
                (store (+ address 8) (vec-d rt2)))
            0b10 (block
                (store address (vec rt1))
                (store (+ address 16) (vec rt2)))
            (unimplemented))
        (= (gpr-or-sp64 rd) address)))

(def STP-simd-signed-offset
    "oo 101 1 010 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd, #$simm]"
    (names (opc o) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (match opc 0b00 "S" 0b01 "D" 0b10 "Q" (unimplemented)))
        (let simm (<< (signext imm i64) (match opc 0b00 2 0b01 3 0b10 4 (unimplemented)))))
    (let address (+ (gpr-or-sp64 rd) simm)
        (match opc
            0b00 (block
                (store address (vec-s rt1))
                (store (+ address 4) (vec-s rt2)))
            0b01 (block
                (store address (vec-d rt1))
                (store (+ address 8) (vec-d rt2)))
            0b10 (block
                (store address (vec rt1))
                (store (+ address 16) (vec rt2)))
            (unimplemented))))

(def STR-immediate-postindex
	"1s 111 0 00 00 0 iiiiiiiii 01 nnnnn ttttt"
	"str $r$rs, [X$rd], #$simm"
	(names (size s) (imm i) (rd n) (rs t))
	(block
		(let r (if (== size 0) "W" "X"))
		(let simm (signext imm i64)))
	(let address (gpr-or-sp64 rd)
		(if (== size 0)
			(store address (gpr32 rs))
			(store address (gpr64 rs)))
		(= (gpr-or-sp64 rd) (+ address simm))))

(def STR-immediate-preindex
	"1s 111 0 00 00 0 iiiiiiiii 11 nnnnn ttttt"
	"str $r$rs, [X$rd, #$simm]!"
	(names (size s) (imm i) (rd n) (rs t))
	(block
		(let r (if (== size 0) "W" "X"))
		(let simm (signext imm i64)))
	(let address (+ (gpr-or-sp64 rd) simm)
		(if (== size 0)
			(store address (gpr32 rs))
			(store address (gpr64 rs)))
		(= (gpr-or-sp64 rd) address)))

(def STR-immediate-unsigned-offset
    "1s 111 0 01 00 iiiiiiiiiiii nnnnn ttttt"
    "str $r$rs, [X$rd, #$pimm]"
    (names (size s) (imm i) (rd n) (rs t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let pimm (<< (u64 imm) (if (== size 0) 2 3))))
    (if (== size 0)
        (store (+ (gpr-or-sp64 rd) pimm) (gpr32 rs))
        (store (+ (gpr-or-sp64 rd) pimm) (gpr64 rs))))

(def STR-register
    "1f 111 0 00 00 1 mmmmm ooo s 10 nnnnn ttttt"
    "str $r1$rt, [X$rn, $r2$rm, $extend $amount]"
    (names (size f) (rm m) (option o) (scale s) (rn n) (rt t))
    (block
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (if (& option 1) "X" "W"))
        (let amount (if (== scale 0) 0 (if (== size 0) 2 3)))
        (let extend (match option
            0b010 "UXTW"
            0b110 "SXTW"
            0b111 "SXTX"
            0b011 "LSL"
            (unimplemented))))
    (let offset (<< (if (== option 0b110)
            (u64 (signext (gpr32 rm) i64))
            (if (& option 1)
                (gpr64 rm)
                (u64 (gpr32 rm)))) amount)
        (if (== size 0)
            (store (+ (gpr-or-sp64 rn) offset) (gpr32 rt))
            (store (+ (gpr-or-sp64 rn) offset) (gpr64 rt)))))

(def STR-simd-postindex
    "ss 111 1 00 o0 0 iiiiiiiii 01 nnnnn ttttt"
    "str $r$rt, [X$rn], #$simm"
    (names (size s) (opc o) (imm i) (rn n) (rt t))
    (block
        (let rop (: size opc (u1 0)))
        (let r (match rop
            0b0000 "B"
            0b0100 "H"
            0b1000 "S"
            0b1100 "D"
            0b0010 "Q"
            (unimplemented)))
        (let simm (signext imm i64)))
    (let address (gpr-or-sp64 rn)
        (match rop
            0b0000 (store address (vec-b rt))
            0b0100 (store address (vec-h rt))
            0b1000 (store address (vec-s rt))
            0b1100 (store address (vec-d rt))
            0b0010 (store address (vec rt))
            (unimplemented))
        (= (gpr-or-sp64 rn) (+ address simm))))

(def STR-simd-preindex
    "ss 111 1 00 o0 0 iiiiiiiii 11 nnnnn ttttt"
    "str $r$rt, [X$rn, #$simm]!"
    (names (size s) (opc o) (imm i) (rn n) (rt t))
    (block
        (let rop (: size opc (u1 0)))
        (let r (match rop
            0b0000 "B"
            0b0100 "H"
            0b1000 "S"
            0b1100 "D"
            0b0010 "Q"
            (unimplemented)))
        (let scale (: opc size))
        (let simm (signext imm i64)))
    (let address (+ (gpr-or-sp64 rn) simm)
        (match rop
            0b0000 (store address (vec-b rt))
            0b0100 (store address (vec-h rt))
            0b1000 (store address (vec-s rt))
            0b1100 (store address (vec-d rt))
            0b0010 (store address (vec rt))
            (unimplemented))
        (= (gpr-or-sp64 rn) address)))

(def STR-simd-unsigned-offset
    "ss 111 1 01 o0 iiiiiiiiiiii nnnnn ttttt"
    "str $r$rt, [X$rn, #$imm]"
    (names (size s) (opc o) (imm i) (rn n) (rt t))
    (block
        (let rop (: size opc (u1 0)))
        (let r (match rop
            0b0000 "B"
            0b0100 "H"
            0b1000 "S"
            0b1100 "D"
            0b0010 "Q"
            (unimplemented)))
        (let scale (: opc size)))
    (let address (+ (gpr-or-sp64 rn) (<< imm scale))
        (match rop
            0b0000 (store address (vec-b rt))
            0b0100 (store address (vec-h rt))
            0b1000 (store address (vec-s rt))
            0b1100 (store address (vec-d rt))
            0b0010 (store address (vec rt))
            (unimplemented))))

(def STR-simd-register
    "ff 111 1 00 x0 1 mmmmm ooo s 10 nnnnn ttttt"
    "str $r1$rt, [X$rn, $r2$rm, $extend $amount]"
    (names (size f) (opc x) (rm m) (option o) (scale s) (rn n) (rt t))
    (block
        (let rop (: size opc (u1 0)))
        (let r1 (match rop
            0b0000 "B"
            0b0100 "H"
            0b1000 "S"
            0b1100 "D"
            0b0010 "Q"
            (unimplemented)))
        (let r2 (if (& option 1) "X" "W"))
        (let amount (if (== scale 0) 0 (match size
            0b01 1
            0b10 2
            0b11 3
            (if (== opc 1) 4 0)
            )))
        (let extend (match option
            0b010 "UXTW"
            0b110 "SXTW"
            0b111 "SXTX"
            0b011 (if (!= rop 0b0000) "LSL" (unimplemented))
            (unimplemented))))
    (let offset (<< (if (== option 0b110)
            (u64 (signext (gpr32 rm) i64))
            (if (& option 1)
                (gpr64 rm)
                (u64 (gpr32 rm)))) amount)
        (let address (+ (gpr-or-sp64 rn) offset)
            (match rop
                0b0000 (store address (vec-b rt))
                0b0100 (store address (vec-h rt))
                0b1000 (store address (vec-s rt))
                0b1100 (store address (vec-d rt))
                0b0010 (store address (vec rt))
                (unimplemented)))))

(def STRB-immediate-postindex
	"00 111 0 00 00 0 iiiiiiiii 01 nnnnn ttttt"
	"strb W$rs, [X$rd], #$simm"
	(names (imm i) (rd n) (rs t))
	(let simm (signext imm i64))
	(let address (gpr-or-sp64 rd)
		(store address (u8 (gpr32 rs)))
		(= (gpr-or-sp64 rd) (+ address simm))))

(def STRB-immediate-preindex
	"00 111 0 00 00 0 iiiiiiiii 11 nnnnn ttttt"
	"strb W$rs, [X$rd, #$simm]!"
	(names (imm i) (rd n) (rs t))
	(let simm (signext imm i64))
	(let address (+ (gpr-or-sp64 rd) simm)
		(store address (u8 (gpr32 rs)))
		(= (gpr-or-sp64 rd) address)))

(def STRB-immediate-unsigned-offset
    "00 111 0 01 00 iiiiiiiiiiii nnnnn ttttt"
    "strb W$rt, [X$rn, #$imm]"
    (names (imm i) (rn n) (rt t))
    (block)
    (store (+ (gpr-or-sp64 rn) imm) (u8 (gpr64 rt))))

(def STRB-register
    "00 111 0 00 00 1 mmmmm ooo s 10 nnnnn ttttt"
    "strb W$rt, [X$rn, $r$rm, $str $amount]"
    (names (rm m) (option o) (amount s) (rn n) (rt t))
    (let r (if (& option 1) "X" "W")
        (let str (match option
            0b010 "UXTW"
            0b011 "LSL"
            0b110 "SXTW"
            0b111 "SXTX"
            (unimplemented))))
    (let offset (<< (if (== option 0b110)
            (u64 (signext (gpr32 rm) i64))
            (if (& option 1)
                (gpr64 rm)
                (u64 (gpr32 rm)))) amount)
        (store (+ (gpr-or-sp64 rn) offset) (u8 (gpr32 rt)))))

(def STRH-immediate-postindex
	"01 111 0 00 00 0 iiiiiiiii 01 nnnnn ttttt"
	"strh W$rs, [X$rd], #$simm"
	(names (imm i) (rd n) (rs t))
	(let simm (signext imm i64))
	(let address (gpr-or-sp64 rd)
		(store address (u16 (gpr32 rs)))
		(= (gpr-or-sp64 rd) (+ address simm))))

(def STRH-immediate-preindex
	"01 111 0 00 00 0 iiiiiiiii 11 nnnnn ttttt"
	"strh W$rs, [X$rd, #$simm]!"
	(names (imm i) (rd n) (rs t))
	(let simm (signext imm i64))
	(let address (+ (gpr-or-sp64 rd) simm)
		(store address (u16 (gpr32 rs)))
		(= (gpr-or-sp64 rd) address)))

(def STRH-immediate-unsigned-offset
    "01 111 0 01 00 iiiiiiiiiiii nnnnn ttttt"
    "strh W$rt, [X$rn, #$imm]"
    (names (rawimm i) (rn n) (rt t))
    (let imm (<< rawimm 1))
    (store (+ (gpr-or-sp64 rn) imm) (u16 (gpr64 rt))))

(def STRH-register
    "01 111 0 00 00 1 mmmmm ooo s 10 nnnnn ttttt"
    "strh W$rt, [X$rn, $r$rm, $str $amount]"
    (names (rm m) (option o) (amount s) (rn n) (rt t))
    (let r (if (& option 1) "X" "W")
        (let str (match option
            0b010 "UXTW"
            0b011 "LSL"
            0b110 "SXTW"
            0b111 "SXTX"
            (unimplemented))))
    (let offset (<< (if (== option 0b110)
            (u64 (signext (gpr32 rm) i64))
            (if (& option 1)
                (gpr64 rm)
                (u64 (gpr32 rm)))) amount)
        (store (+ (gpr-or-sp64 rn) offset) (u16 (gpr32 rt)))))

(def STUR
    "1s 111 0 00 00 0 iiiiiiiii 00 nnnnn ttttt"
    "stur $r$rt, [X$rn, #$offset]"
    (names (size s) (imm i) (rn n) (rt t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let offset (signext imm i64)))
    (if (== size 0)
        (store (+ (gpr-or-sp64 rn) offset) (gpr32 rt))
        (store (+ (gpr-or-sp64 rn) offset) (gpr64 rt))))

(def STUR-simd
    "ss 111 1 00 o0 0 iiiiiiiii 00 nnnnn ttttt"
    "stur $r$rt, [X$rn, #$simm]"
    (names (size s) (opc o) (imm i) (rn n) (rt t))
    (block
        (let rop (: size opc (u1 0)))
        (let r (match rop
            0b0000 "B"
            0b0100 "H"
            0b1000 "S"
            0b1100 "D"
            0b0010 "Q"
            (unimplemented)))
        (let simm (signext imm i64)))
    (let address (+ (gpr-or-sp64 rn) simm)
        (match rop
            0b0000 (store address (vec-b rt))
            0b0100 (store address (vec-h rt))
            0b1000 (store address (vec-s rt))
            0b1100 (store address (vec-d rt))
            0b0010 (store address (vec rt))
            (unimplemented))))

(def STURB
    "00 111 0 00 00 0 iiiiiiiii 00 nnnnn ttttt"
    "sturb W$rt, [X$rn, #$offset]"
    (names (imm i) (rn n) (rt t))
    (let offset (signext imm i64))
    (store (+ (gpr-or-sp64 rn) offset) (u8 (gpr64 rt))))

(def STURH
    "01 111 0 00 00 0 iiiiiiiii 00 nnnnn ttttt"
    "sturh W$rt, [X$rn, #$offset]"
    (names (imm i) (rn n) (rt t))
    (let offset (signext imm i64))
    (store (+ (gpr-or-sp64 rn) offset) (u16 (gpr64 rt))))

(def STXRB
    "00 001000 0 0 0 sssss 0 11111 nnnnn ttttt"
    "stxrb W$rs, W$rt, [X$rn]"
    (names (rs s) (rn n) (rt t))
    (block)
    (= (gpr32 rs) (store-exclusive (gpr-or-sp64 rn) (u8 (gpr32 rt)))))

(def STXR
    "1f 001000 0 0 0 sssss 0 11111 nnnnn ttttt"
    "stxr W$rs, $r$rt, [X$rn]"
    (names (size f) (rs s) (rn n) (rt t))
    (let r (if (== size 0) "W" "X"))
    (= (gpr32 rs)
        (if (== size 0)
            (store-exclusive (gpr-or-sp64 rn) (gpr32 rt))
            (store-exclusive (gpr-or-sp64 rn) (gpr64 rt)))))

(def STXP
    "1 f 001000 0 0 1 sssss 0 uuuuu nnnnn ttttt"
    "stxp W$rs, $r$rt, $r$rt2, [X$rn]"
    (names (size f) (rs s) (rt2 u) (rn n) (rt t))
    (let r (if (== size 0) "W" "X"))
    (let address (gpr-or-sp64 rn)
        (= (gpr32 rs)
            (if (== size 0)
                (|
                    (store-exclusive address (gpr32 rt))
                    (store-exclusive (+ address 4) (gpr32 rt)))
                (|
                    (store-exclusive address (gpr64 rt))
                    (store-exclusive (+ address 8) (gpr64 rt)))))))

(def SUB-immediate
    "f 1 0 10001 0s iiiiiiiiiiii nnnnn ddddd"
    "sub $r$rd, $r$rn, #$imm, LSL #$shift"
    (names (size f) (sh s) (imm i) (rd d) (rn n))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shift (if (== sh 0) 0 12)))
    (if (== size 0)
        (= (gpr-or-sp32 rd) (- (gpr-or-sp32 rn) (<< (u32 imm) shift)))
        (= (gpr-or-sp64 rd) (- (gpr-or-sp64 rn) (<< (u64 imm) shift)))))

(def SUB-extended-register
    "s 1 0 01011 00 1 mmmmm ooo iii nnnnn ddddd"
    "sub $r1$rd, $r1$rn, $r2$rm, $extend #$imm"
    (names (size s) (rm m) (option o) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm 4))
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (if (== (& option 0b011) 0b011) "X" "W"))
        (let extend (if (== size 0)
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "LSL"
                0b011 "UXTX"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX")
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "UXTW"
                0b011 "LSL"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX"))))
    (if (== size 0)
        (let m (gpr32 rm)
            (= (gpr-or-sp32 rd) (- (gpr-or-sp32 rn) (<< (match option
                0b000 (& m 0xFF)
                0b001 (& m 0xFFFF)
                0b100 (u32 (signext (u8 m) i32))
                0b101 (u32 (signext (u16 m) i32))
                m) imm))))
        (if (== (& option 0b011) 0b011)
            (= (gpr-or-sp64 rd) (- (gpr-or-sp64 rn) (<< (gpr64 rm) imm)))
            (let m (gpr32 rm)
                (= (gpr-or-sp64 rd) (- (gpr-or-sp64 rn) (<< (u64 (match option
                    0b000 (& m 0xFF)
                    0b001 (& m 0xFFFF)
                    0b010 (& m 0xFFFFFFFF)
                    0b100 (signext (u8 m) i64)
                    0b101 (signext (u16 m) i64)
                    0b110 (signext m i64)
                    m)) imm)))))))

(def SUB-shifted-register
    "f 1 0 01011 ss 0 mmmmm iiiiii nnnnn ddddd"
    "sub $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (imm i) (rd d) (rn n) (rm m))
    (block
        (requires (<= imm (if size 63 31)))
        (requires (!= shift 0b11))
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (shift-string shift)))
    (if (== size 0)
        (= (gpr32 rd) (- (gpr32 rn) (do-shift32 (gpr32 rm) shift imm)))
        (= (gpr64 rd) (- (gpr64 rn) (do-shift64 (gpr64 rm) shift imm)))))

(def SUBS-extended-register
    "s 1 1 01011 00 1 mmmmm ooo iii nnnnn ddddd"
    "subs $r1$rd, $r1$rn, $r2$rm, $extend #$imm"
    (names (size s) (rm m) (option o) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm 4))
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (if (== (& option 0b011) 0b011) "X" "W"))
        (let extend (if (== size 0)
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "LSL"
                0b011 "UXTX"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX")
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "UXTW"
                0b011 "LSL"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX"))))
    (if (== size 0)
        (let m (gpr32 rm)
            (= (gpr32 rd) (add-with-carry-set-nzcv32 (gpr-or-sp32 rn) (~ (<< (match option
                0b000 (& m 0xFF)
                0b001 (& m 0xFFFF)
                0b100 (u32 (signext (u8 m) i32))
                0b101 (u32 (signext (u16 m) i32))
                m) imm)) 1)))
        (if (== (& option 0b011) 0b011)
            (= (gpr64 rd) (add-with-carry-set-nzcv64 (gpr-or-sp64 rn) (~ (<< (gpr64 rm) imm)) 1))
            (let m (gpr32 rm)
                (= (gpr64 rd) (add-with-carry-set-nzcv64 (gpr-or-sp64 rn) (~ (<< (u64 (match option
                    0b000 (& m 0xFF)
                    0b001 (& m 0xFFFF)
                    0b010 (& m 0xFFFFFFFF)
                    0b100 (signext (u8 m) i64)
                    0b101 (signext (u16 m) i64)
                    0b110 (signext m i64)
                    m)) imm)) 1))))))

(def SUBS-shifted-register
    "s 1 1 01011 hh 0 mmmmm iiiiii nnnnn ddddd"
    "subs $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size s) (shift h) (rm m) (imm i) (rn n) (rd d))
    (block
        (requires (<= imm (if size 63 31)))
        (requires (!= shift 0b11))
        (let mode32 (== size 0))
        (let r (if mode32 "W" "X"))
        (let shiftstr (shift-string shift)))
    (if mode32
        (= (gpr32 rd) (add-with-carry-set-nzcv32 (gpr32 rn) (~ (do-shift32 (gpr32 rm) shift imm)) 1))
        (= (gpr64 rd) (add-with-carry-set-nzcv64 (gpr64 rn) (~ (do-shift64 (gpr64 rm) shift imm)) 1))))

(def SUBS-immediate
    "s 1 1 10001 0h iiiiiiiiiiii nnnnn ddddd"
    "subs $r$rd, $r$rn, #$imm, $shiftstr"
    (names (size s) (shift h) (imm i) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (match shift
            0b00 "LSL #0"
            0b01 "LSL #12"
            (unimplemented))))
    (let rimm (if shift (<< (u32 imm) 12) imm)
        (if (== size 0)
            (= (gpr32 rd) (add-with-carry-set-nzcv32 (gpr32 rn) (~ (u32 rimm)) 1))
            (= (gpr64 rd) (add-with-carry-set-nzcv64 (gpr64 rn) (~ (u64 rimm)) 1)))))

(def SVC
    "11010100 000 iiiiiiiiiiiiiiii 000 01"
    "svc #$imm"
    (names (imm i))
    (block)
    (svc imm))

(def SYS
    "1101010100 0 01 ooo nnnn mmmm ppp ttttt"
    "sys #$op1, $cn, $cm, #$op2, X$rt"
    (names (op1 o) (cn n) (cm m) (op2 p) (rt t))
    (block)
    (block))

(def TBZ
    "u 011011 0 bbbbb iiiiiiiiiiiiii ttttt"
    "tbz $r$rt, #$imm, $addr"
    (names (upper u) (bottom b) (offset i) (rt t))
    (block
        (let r (if (== upper 0) "W" "X"))
        (let imm (| (<< (u32 upper) 5) (u32 bottom)))
        (let addr (+ (pc) (signext (<< (u16 offset) 2) i64))))
    (if (& (>> (gpr64 rt) imm) 1)
        (branch-default)
        (branch addr)))

(def TBNZ
    "u 011011 1 bbbbb iiiiiiiiiiiiii ttttt"
    "tbnz $r$rt, #$imm, $addr"
    (names (upper u) (bottom b) (offset i) (rt t))
    (block
        (let r (if (== upper 0) "W" "X"))
        (let imm (| (<< (u32 upper) 5) (u32 bottom)))
        (let addr (+ (pc) (signext (<< (u16 offset) 2) i64))))
    (if (& (>> (gpr64 rt) imm) 1)
        (branch addr)
        (branch-default)))

(def UADDLV
    "0 q 1 01110 ss 11000 00011 10 nnnnn ddddd"
    "uaddlv $r$rd, V$rn.$t"
    (names (Q q) (size s) (rn n) (rd d))
    (block
        (let r (match size
            0b00 "H"
            0b01 "S"
            0b10 "D"
            (unimplemented)))
        (let t (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_1 "4S"
            (unimplemented)))
        (let esize (<< 8 size))
        (let count (/ (if Q 128 64) esize)))
    (match size
        0b00 (= (vec-h rd) (cast (vector-sum-unsigned (vec rn) esize count) u16))
        0b01 (= (vec-s rd) (bitcast (vector-sum-unsigned (vec rn) esize count) f32))
        0b10 (= (vec-d rd) (bitcast (u64 (vector-sum-unsigned (vec rn) esize count)) f64))
        (unimplemented)))

(defm uaddw-sub (count wide thin)
    (for (i count) (vector-insert rd i (+ (vector-element a i wide) (wide (vector-element b (if Q (literal (+ i count)) i) thin))))))

(def UADDW[2]
    "0 Q 1 01110 ss 1 mmmmm 00 0 1 00 nnnnn ddddd"
    "uaddw$o2 V$rd.$Ta, V$rn.$Ta, V$rm.$Tb"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (mlet (o2 (if Q "2" "") Ta "" Tb "")
        (match (: size Q)
            0b00_0 (block (= Ta "8H") (= Tb "8B"))
            0b00_1 (block (= Ta "8H") (= Tb "16B"))
            0b01_0 (block (= Ta "4S") (= Tb "4H"))
            0b01_1 (block (= Ta "4S") (= Tb "8H"))
            0b10_0 (block (= Ta "2D") (= Tb "2S"))
            0b10_1 (block (= Ta "2D") (= Tb "4S"))
            (unimplemented)))
    (mlet (a (vec rn) b (vec rm))
        (match size
            0b00 (uaddw-sub 8 u16 u8)
            0b01 (uaddw-sub 4 u32 u16)
            0b10 (uaddw-sub 2 u64 u32)
            (unimplemented))))

(def UBFM
    "f 10 100110 o pppppp ssssss nnnnn ddddd"
    "ubfm $r$rd, $r$rn, #$immr, #$imms"
    (names (N o) (size f) (immr p) (imms s) (rn n) (rd d))
    (block
        (requires (<= imms (if size 63 31)))
        (requires (<= immr (if size 63 31)))
        (if size
            (requires N)
            (requires (== N 0)))
        (let r (if (== size 0) "W" "X")))
    (if (== size 0)
        (block
            (let src (gpr32 rn))
            (let wmask (u32 (make-wmask N imms immr 0 32)))
            (let tmask (u32 (make-tmask N imms immr 0 32)))
            (let bot (& (>>> src immr) wmask))
            (= (gpr32 rd) (& bot tmask)))
        (block
            (let src (gpr64 rn))
            (let wmask (make-wmask N imms immr 0 64))
            (let tmask (make-tmask N imms immr 0 64))
            (let bot (& (>>> src immr) wmask))
            (= (gpr64 rd) (& bot tmask)))))

(def UCVTF-scalar-gpr-integer
    "s 0 0 11110 tt 1 00 011 000000 nnnnn ddddd"
    "ucvtf $r1$rd, $r2$rn"
    (names (size s) (type t) (rn n) (rd d))
    (block
        (let st (: size type))
        (let r1 "") (let r2 "")
        (match st
            0b0_11 (block (= r1 "H") (= r2 "W"))
            0b0_00 (block (= r1 "S") (= r2 "W"))
            0b0_01 (block (= r1 "D") (= r2 "W"))
            0b1_11 (block (= r1 "H") (= r2 "X"))
            0b1_00 (block (= r1 "S") (= r2 "X"))
            0b1_01 (block (= r1 "D") (= r2 "X"))
            (unimplemented)))
    (match st
        0b0_00 (= (vec-s rd) (f32 (gpr32 rn)))
        0b0_01 (= (vec-d rd) (f64 (gpr32 rn)))
        0b1_00 (= (vec-s rd) (f32 (gpr64 rn)))
        0b1_01 (= (vec-d rd) (f64 (gpr64 rn)))
        (unimplemented)))

(def UCVTF-scalar-integer
    "01 1 11110 0 s 10000 11101 10 nnnnn ddddd"
    "ucvtf $r$rd, $r$rn"
    (names (size s) (rn n) (rd d))
    (let r (if (== size 0) "S" "D"))
    (if (== size 0)
        (= (vec-s rd) (f32 (bitcast (vec-s rn) u32)))
        (= (vec-d rd) (f64 (bitcast (vec-d rn) u64)))))

(def UCVTF-vector
    "0 Q 1 01110 0 s 10000 11101 10 nnnnn ddddd"
    "ucvtf V$rd.$t, V$rn.$t"
    (names (Q Q) (size s) (rn n) (rd d))
    (let t (match (: size Q)
        0b00 "2S"
        0b01 "4S"
        0b11 "2D"
        (unimplemented)))
    (let n (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (match (: size Q)
            0b00 (block
                    (vector-insert rd 0 (f32 (vector-element n 0 u32)))
                    (vector-insert rd 1 (f32 (vector-element n 1 u32))))
            0b01 (block
                    (vector-insert rd 0 (f32 (vector-element n 0 u32)))
                    (vector-insert rd 1 (f32 (vector-element n 1 u32)))
                    (vector-insert rd 2 (f32 (vector-element n 2 u32)))
                    (vector-insert rd 3 (f32 (vector-element n 3 u32))))
            0b11 (block
                    (vector-insert rd 0 (f64 (vector-element n 0 u64)))
                    (vector-insert rd 1 (f64 (vector-element n 1 u64))))
            (unimplemented))))

(def UDIV
    "f 0 0 11010110 mmmmm 00001 0 nnnnn ddddd"
    "udiv $r$rd, $r$rn, $r$rm"
    (names (size f) (rm m) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (let operand2 (gpr32 rm)
            (= (gpr32 rd) (if (== operand2 0)
                (u32 0)
                (/ (gpr32 rn) operand2))))
        (let operand2 (gpr64 rm)
            (= (gpr64 rd) (if (== operand2 0)
                (u64 0)
                (/ (gpr64 rn) operand2))))))

(def UMADDL
    "1 00 11011 1 01 mmmmm 0 aaaaa nnnnn ddddd"
    "umaddl X$rd, W$rn, W$rm, X$ra"
    (names (rd d) (rn n) (rm m) (ra a))
    (block)
    (= (gpr64 rd) (+ (gpr64 ra) (* (u64 (gpr32 rn)) (u64 (gpr32 rm))))))

(def UMOV
    "0 Q 0 01110000 iiiii 0 01 1 1 1 nnnnn ddddd"
    "umov $r$rd, V$rn.$T[$index]"
    (names (Q Q) (imm i) (rn n) (rd d))
    (mlet (T "" index 0
            r (if Q "X" "W")
            comb (: Q imm)
            size (if (== (& 0b100001) 0b000001) 8
                    (if (== (& 0b100011) 0b000010) 16
                    (if (== (& 0b100111) 0b000100) 32
                    (if (== (& 0b101111) 0b101000) 64
                    (unimplemented))))))
        (match size
            8  (block (= T "B") (= index (>> imm 1)))
            16 (block (= T "H") (= index (>> imm 2)))
            32 (block (= T "S") (= index (>> imm 3)))
               (block (= T "D") (= index (>> imm 4)))))
    (let v (vec rn)
        (if Q
            (= (gpr64 rd) (vector-element v index u64))
            (= (gpr32 rd) (match size
                8  (u32 (vector-element v index u8))
                16 (u32 (vector-element v index u16))
                        (vector-element v index u32))))))

(def UMULH
    "1 00 11011 1 10 mmmmm 0 11111 nnnnn ddddd"
    "umulh X$rd, X$rn, X$rm"
    (names (rm m) (rn n) (rd d))
    (block)
    (= (gpr64 rd) (u64 (>> (* (cast (gpr64 rn) u128) (cast (gpr64 rm) u128)) 64))))

(defm ushl-sub (i type) (vector-insert rd i (<< (vector-element n i type) (u8 (vector-element m i type)))))

(def USHL-vector
    "0 Q 1 01110 ss 1 mmmmm 010 0 0 1 nnnnn ddddd"
    "ushl V$rd.$t, V$rn.$t, V$rm.$t"
    (names (Q Q) (size s) (rm m) (rn n) (rd d))
    (let t (match (: size Q)
        0b00_0 "8B"
        0b00_1 "16B"
        0b01_0 "4H"
        0b01_1 "8H"
        0b10_0 "2S"
        0b10_1 "4S"
        0b11_1 "2D"
        (unimplemented)))
    (mlet (n (vec rn) m (vec rm))
        (= (vec rd) (vector-all (u8 0)))
        (match (: size Q)
            0b00_0 (block
                    (ushl-sub 0 u8) (ushl-sub 1 u8) (ushl-sub 2 u8) (ushl-sub 3 u8)
                    (ushl-sub 4 u8) (ushl-sub 5 u8) (ushl-sub 6 u8) (ushl-sub 7 u8))
            0b00_1 (block
                    (ushl-sub  0 u8) (ushl-sub  1 u8) (ushl-sub  2 u8) (ushl-sub  3 u8)
                    (ushl-sub  4 u8) (ushl-sub  5 u8) (ushl-sub  6 u8) (ushl-sub  7 u8)
                    (ushl-sub  8 u8) (ushl-sub  9 u8) (ushl-sub 10 u8) (ushl-sub 11 u8)
                    (ushl-sub 12 u8) (ushl-sub 13 u8) (ushl-sub 14 u8) (ushl-sub 15 u8))
            0b01_0 (block
                    (ushl-sub 0 u16) (ushl-sub 1 u16) (ushl-sub 2 u16) (ushl-sub 3 u16))
            0b01_1 (block
                    (ushl-sub 0 u16) (ushl-sub 1 u16) (ushl-sub 2 u16) (ushl-sub 3 u16)
                    (ushl-sub 4 u16) (ushl-sub 5 u16) (ushl-sub 6 u16) (ushl-sub 7 u16))
            0b10_0 (block (ushl-sub 0 u32) (ushl-sub 1 u32))
            0b10_1 (block (ushl-sub 0 u32) (ushl-sub 1 u32) (ushl-sub 2 u32) (ushl-sub 3 u32))
            0b11_1 (block (ushl-sub 0 u64) (ushl-sub 1 u64))
                   (unimplemented))))

(defm ushll-sub (si di stype dtype) (vector-insert rd di (<< (cast (vector-element n si stype) dtype) shift)))

(def USHLL-vector
    "0 Q 1 011110 hhhh bbb 10100 1 nnnnn ddddd"
    "ushll$i2 V$rd.$Ta, V$rn.$Tb, #$shift"
    (names (Q Q) (immh h) (immb b) (rn n) (rd d))
    (mlet (Ta "" Tb "" size 0 shift 0)
        (requires (!= immh 0b0000))
        (let i2 (if Q "2" ""))
        (if (== immh 0b0001)            (block (= Ta "8H") (= Tb (if Q "16B" "8B")) (= size 0b00) (= shift (- (u32 (: immh immb)) 8)))
        (if (== (& immh 0b1110) 0b0010) (block (= Ta "4S") (= Tb (if Q "8H" "4H")) (= size 0b01) (= shift (- (u32 (: immh immb)) 16)))
        (if (== (& immh 0b1100) 0b0100) (block (= Ta "2D") (= Tb (if Q "4S" "2S")) (= size 0b10) (= shift (- (u32 (: immh immb)) 32)))
                                        (unimplemented)))))
    (mlet (n (vec rn))
        (= (vec rd) (vector-all (u8 0)))
        (match (: size Q)
            0b00_0 (block
                    (ushll-sub 0 0 u8 u16) (ushll-sub 1 1 u8 u16) (ushll-sub 2 2 u8 u16) (ushll-sub 3 3 u8 u16)
                    (ushll-sub 4 4 u8 u16) (ushll-sub 5 5 u8 u16) (ushll-sub 6 6 u8 u16) (ushll-sub 7 7 u8 u16))
            0b00_1 (block
                    (ushll-sub 8  0 u8 u16) (ushll-sub 9  1 u8 u16) (ushll-sub 10 2 u8 u16) (ushll-sub 11 3 u8 u16)
                    (ushll-sub 12 4 u8 u16) (ushll-sub 13 5 u8 u16) (ushll-sub 14 6 u8 u16) (ushll-sub 15 7 u8 u16))
            0b01_0 (block
                    (ushll-sub 0 0 u16 u32) (ushll-sub 1 1 u16 u32) (ushll-sub 2 2 u16 u32) (ushll-sub 3 3 u16 u32))
            0b01_1 (block
                    (ushll-sub 4 0 u16 u32) (ushll-sub 5 1 u16 u32) (ushll-sub 6 2 u16 u32) (ushll-sub 7 3 u16 u32))
            0b10_0 (block (ushll-sub 0 0 u32 u64) (ushll-sub 1 1 u32 u64))
            0b10_1 (block (ushll-sub 2 0 u32 u64) (ushll-sub 3 1 u32 u64))
                   (unimplemented))))

(defm xtn-sub (count wide thin base)
    (for (i count) (vector-insert rd (+ base i) (thin (vector-element v i wide)))))

(def XTN
    "0 0 0 01110 ss 10000 10010 10 nnnnn ddddd"
    "xtn V$rd.$tb, V$rn.$ta"
    (names (size s) (rn n) (rd d))
    (block
        (let tb (match size
            0b00 "8B"
            0b01 "4H"
            0b10 "2S"
            (unimplemented)))
        (let ta (match size
            0b00 "8H"
            0b01 "4S"
            0b10 "2D"
            (unimplemented))))
    (let v (vec rn)
        (= (vec rd) (vector-all (u8 0)))
        (match size
            0b00 (xtn-sub 8 u16 u8 0)
            0b01 (xtn-sub 4 u32 u16 0)
            0b10 (xtn-sub 2 u64 u32 0)
            (unimplemented))))

(def XTN2
    "0 1 0 01110 ss 10000 10010 10 nnnnn ddddd"
    "xtn2 V$rd.$tb, V$rn.$ta"
    (names (size s) (rn n) (rd d))
    (block
        (let tb (match size
            0b00 "16B"
            0b01 "8H"
            0b10 "4S"
            (unimplemented)))
        (let ta (match size
            0b00 "8H"
            0b01 "4S"
            0b10 "2D"
            (unimplemented))))
    (let v (vec rn)
        (match size
            0b00 (xtn-sub 8 u16 u8 8)
            0b01 (xtn-sub 4 u32 u16 4)
            0b10 (xtn-sub 2 u64 u32 2)
            (unimplemented))))

(def YIELD
    "1101010100 0 00 011 0010 0000 001 11111"
    "yield"
    (names)
    (block)
    (block))

(def ZIP
    "0 Q 001110 ss 0 mmmmm 0 o 11 10 nnnnn ddddd"
    "zip$i V$rd.$T, V$rn.$T, V$rm.$T"
    (names (Q Q) (size s) (rm m) (op o) (rn n) (rd d))
    (let i (u8 (+ op 1))
        (let T (match (: size Q)
            0b00_0 "8B"
            0b00_1 "16B"
            0b01_0 "4H"
            0b01_1 "8H"
            0b10_0 "2S"
            0b10_1 "4S"
            0b11_1 "2D"
            (unimplemented))))
    (mlet (av (vec rn) bv (vec rm))
        (= (vec rd) (vector-all (u8 0)))
        (let base (* (u32 op) (/ (/ (if Q 128 64) (<< 8 size)) 2))
            (match size
                0b00 (block
                    (vector-insert rd 0 (vector-element av (+ base 0) u8))
                    (vector-insert rd 2 (vector-element av (+ base 1) u8))
                    (vector-insert rd 4 (vector-element av (+ base 2) u8))
                    (vector-insert rd 6 (vector-element av (+ base 3) u8))
                    (vector-insert rd 1 (vector-element bv (+ base 0) u8))
                    (vector-insert rd 3 (vector-element bv (+ base 1) u8))
                    (vector-insert rd 5 (vector-element bv (+ base 2) u8))
                    (vector-insert rd 7 (vector-element bv (+ base 3) u8))
                    (when Q
                        (vector-insert rd 8  (vector-element av (+ base 4) u8))
                        (vector-insert rd 10 (vector-element av (+ base 5) u8))
                        (vector-insert rd 12 (vector-element av (+ base 6) u8))
                        (vector-insert rd 14 (vector-element av (+ base 7) u8))
                        (vector-insert rd 9  (vector-element bv (+ base 4) u8))
                        (vector-insert rd 11 (vector-element bv (+ base 5) u8))
                        (vector-insert rd 13 (vector-element bv (+ base 6) u8))
                        (vector-insert rd 15 (vector-element bv (+ base 7) u8))))
                0b01 (block
                    (vector-insert rd 0 (vector-element av (+ base 0) u16))
                    (vector-insert rd 2 (vector-element av (+ base 1) u16))
                    (vector-insert rd 1 (vector-element bv (+ base 0) u16))
                    (vector-insert rd 3 (vector-element bv (+ base 1) u16))
                    (when Q
                        (vector-insert rd 4 (vector-element av (+ base 2) u16))
                        (vector-insert rd 6 (vector-element av (+ base 3) u16))
                        (vector-insert rd 5 (vector-element bv (+ base 2) u16))
                        (vector-insert rd 7 (vector-element bv (+ base 3) u16))))
                0b10 (block
                    (vector-insert rd 0 (vector-element av (+ base 0) u32))
                    (vector-insert rd 1 (vector-element bv (+ base 0) u32))
                    (when Q
                        (vector-insert rd 2 (vector-element av (+ base 1) u32))
                        (vector-insert rd 3 (vector-element bv (+ base 1) u32))))
                     (block
                    (vector-insert rd 0 (vector-element av (+ base 0) u64))
                    (vector-insert rd 1 (vector-element bv (+ base 0) u64)))))))